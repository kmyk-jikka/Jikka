-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A transpiler from Python to C++ for competitive programming
--   
--   Please see the README on GitHub at
--   <a>https://github.com/kmyk/Jikka</a>
@package Jikka
@version 5.1.0.0


-- | <a>Expr</a> module has the basic data types for C++ language. The data
--   types are intended to use for the code generation.
module Jikka.CPlusPlus.Language.Expr
newtype VarName
VarName :: String -> VarName
[unVarName] :: VarName -> String
newtype FunName
FunName :: String -> FunName
[unFunName] :: FunName -> String
data Type
TyAuto :: Type
TyVoid :: Type
TyBool :: Type
TyInt :: Type
TyInt32 :: Type
TyInt64 :: Type
TyTuple :: [Type] -> Type
TyVector :: Type -> Type
TyArray :: Type -> Integer -> Type
TyString :: Type
TyFunction :: Type -> [Type] -> Type
TyConvexHullTrick :: Type
TySegmentTree :: Monoid' -> Type

-- | for template parameters
TyIntValue :: Integer -> Type
data Monoid'
MonoidIntPlus :: Monoid'
MonoidIntMin :: Monoid'
MonoidIntMax :: Monoid'
data Literal
LitInt32 :: Integer -> Literal
LitInt64 :: Integer -> Literal
LitBool :: Bool -> Literal
LitChar :: Char -> Literal
LitString :: String -> Literal
data Function
Function :: FunName -> [Type] -> Function
Method :: FunName -> Function
At :: Function
Cast :: Type -> Function
StdTuple :: [Type] -> Function
StdGet :: Integer -> Function
ArrayExt :: Type -> Function
VecExt :: Type -> Function
VecCtor :: Type -> Function
Range :: Function
MethodSize :: Function
ConvexHullTrickCtor :: Function
ConvexHullTrickCopyAddLine :: Function
SegmentTreeCtor :: Monoid' -> Function
SegmentTreeCopySetPoint :: Monoid' -> Function
data UnaryOp
IntNop :: UnaryOp
Negate :: UnaryOp
BitNot :: UnaryOp
Not :: UnaryOp
Deref :: UnaryOp
data BinaryOp
Add :: BinaryOp
Sub :: BinaryOp
Mul :: BinaryOp
Div :: BinaryOp
Mod :: BinaryOp
BitAnd :: BinaryOp
BitOr :: BinaryOp
BitXor :: BinaryOp
BitLeftShift :: BinaryOp
BitRightShift :: BinaryOp
And :: BinaryOp
Or :: BinaryOp
LessThan :: BinaryOp
LessEqual :: BinaryOp
GreaterThan :: BinaryOp
GreaterEqual :: BinaryOp
Equal :: BinaryOp
NotEqual :: BinaryOp
data AssignOp
SimpleAssign :: AssignOp
AddAssign :: AssignOp
SubAssign :: AssignOp
MulAssign :: AssignOp
DivAssign :: AssignOp
ModAssign :: AssignOp
BitLeftShiftAssign :: AssignOp
BitRightShiftAssign :: AssignOp
BitAndAssign :: AssignOp
BitOrAssign :: AssignOp
BitXorAssign :: AssignOp
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr
UnOp :: UnaryOp -> Expr -> Expr
BinOp :: BinaryOp -> Expr -> Expr -> Expr
Cond :: Expr -> Expr -> Expr -> Expr
Lam :: [(Type, VarName)] -> Type -> [Statement] -> Expr
Call :: Function -> [Expr] -> Expr
CallExpr :: Expr -> [Expr] -> Expr
data LeftExpr
LeftVar :: VarName -> LeftExpr
LeftAt :: LeftExpr -> Expr -> LeftExpr

-- | <pre>
--   std::get<a>n</a>
--   </pre>
LeftGet :: Integer -> LeftExpr -> LeftExpr
data AssignExpr
AssignExpr :: AssignOp -> LeftExpr -> Expr -> AssignExpr
AssignIncr :: LeftExpr -> AssignExpr
AssignDecr :: LeftExpr -> AssignExpr
data DeclareRight
DeclareDefault :: DeclareRight
DeclareCopy :: Expr -> DeclareRight

-- | This is only for better formatting. This should not be used while
--   optimization phases.
DeclareInitialize :: [Expr] -> DeclareRight
data Statement
ExprStatement :: Expr -> Statement
Block :: [Statement] -> Statement
If :: Expr -> [Statement] -> Maybe [Statement] -> Statement
For :: Type -> VarName -> Expr -> Expr -> AssignExpr -> [Statement] -> Statement
ForEach :: Type -> VarName -> Expr -> [Statement] -> Statement
While :: Expr -> [Statement] -> Statement
Declare :: Type -> VarName -> DeclareRight -> Statement
DeclareDestructure :: [VarName] -> Expr -> Statement
Assign :: AssignExpr -> Statement
Assert :: Expr -> Statement
Return :: Expr -> Statement
data ToplevelStatement
VarDef :: Type -> VarName -> Expr -> ToplevelStatement
FunDef :: Type -> VarName -> [(Type, VarName)] -> [Statement] -> ToplevelStatement
newtype Program
Program :: [ToplevelStatement] -> Program
[decls] :: Program -> [ToplevelStatement]
instance Data.String.IsString Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.VarName
instance Data.String.IsString Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.FunName
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Monoid'
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Monoid'
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Monoid'
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Monoid'
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Type
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Literal
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Function
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.UnaryOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.BinaryOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.AssignOp
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.LeftExpr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.AssignExpr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Expr
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.DeclareRight
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.DeclareRight
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.DeclareRight
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.DeclareRight
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Statement
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.ToplevelStatement
instance GHC.Read.Read Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Show.Show Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Expr.Program
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Expr.Program

module Jikka.CPlusPlus.Language.VariableAnalysis
data ReadWriteList
ReadWriteList :: Set VarName -> Set VarName -> ReadWriteList
[readList'] :: ReadWriteList -> Set VarName
[writeList] :: ReadWriteList -> Set VarName
readVariable :: VarName -> ReadWriteList
writeVariable :: VarName -> ReadWriteList
analyzeExpr :: Expr -> ReadWriteList
analyzeLeftExpr :: LeftExpr -> ReadWriteList
analyzeAssignExpr :: AssignExpr -> ReadWriteList
analyzeStatement :: Statement -> ReadWriteList
analyzeStatements :: [Statement] -> ReadWriteList
instance GHC.Read.Read Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList
instance GHC.Show.Show Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList
instance GHC.Base.Semigroup Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList
instance GHC.Base.Monoid Jikka.CPlusPlus.Language.VariableAnalysis.ReadWriteList


-- | <a>Alpha</a> provides a monad to run alpha-conversion. This monad has
--   only a feature to make unique numbers.
module Jikka.Common.Alpha
class Monad m => MonadAlpha m
nextCounter :: MonadAlpha m => m Int
newtype AlphaT m a
AlphaT :: (Int -> m (a, Int)) -> AlphaT m a
[runAlphaT] :: AlphaT m a -> Int -> m (a, Int)
liftCatch :: Catch e m (a, Int) -> Catch e (AlphaT m) a
evalAlphaT :: Functor m => AlphaT m a -> Int -> m a
evalAlpha :: AlphaT Identity a -> Int -> a
resetAlphaT :: Monad m => Int -> AlphaT m ()
instance GHC.Base.Monad m => Jikka.Common.Alpha.MonadAlpha (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Functor m => GHC.Base.Functor (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Jikka.Common.Alpha.AlphaT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.Fix.MonadFix m => Control.Monad.Fix.MonadFix (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.Trans.Class.MonadTrans Jikka.Common.Alpha.AlphaT
instance Control.Monad.Error.Class.MonadError e m => Control.Monad.Error.Class.MonadError e (Jikka.Common.Alpha.AlphaT m)
instance Control.Monad.IO.Class.MonadIO m => Control.Monad.IO.Class.MonadIO (Jikka.Common.Alpha.AlphaT m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Except.ExceptT e m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Reader.ReaderT r m)
instance Jikka.Common.Alpha.MonadAlpha m => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.State.Strict.StateT s m)
instance (Jikka.Common.Alpha.MonadAlpha m, GHC.Base.Monoid w) => Jikka.Common.Alpha.MonadAlpha (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance Jikka.Common.Alpha.MonadAlpha GHC.Types.IO
instance Jikka.Common.Alpha.MonadAlpha Language.Haskell.TH.Syntax.Q

module Jikka.CPlusPlus.Language.Util
fromLeftExpr :: LeftExpr -> Expr
data NameKind
LocalNameKind :: NameKind
LocalArgumentNameKind :: NameKind
LoopCounterNameKind :: NameKind
ConstantNameKind :: NameKind
FunctionNameKind :: NameKind
ArgumentNameKind :: NameKind
fromNameKind :: NameKind -> String
newFreshName :: MonadAlpha m => NameKind -> m VarName
renameVarName :: MonadAlpha m => NameKind -> String -> m VarName
freeVars :: Expr -> Set VarName
freeVarsStatements :: [Statement] -> Set VarName
freeVarsStatement :: Statement -> Set VarName
freeVarsDeclareRight :: DeclareRight -> Set VarName
freeVarsAssignExpr :: AssignExpr -> Set VarName
freeVarsLeftExpr :: LeftExpr -> Set VarName
shouldBeArray :: [Type] -> Bool
cinStatement :: Expr -> Statement
coutStatement :: Expr -> Statement
repStatement :: VarName -> Expr -> [Statement] -> Statement
litInt64 :: Integer -> Expr
litInt32 :: Integer -> Expr
incrExpr :: Expr -> Expr
size :: Expr -> Expr
at :: Expr -> Expr -> Expr
cast :: Type -> Expr -> Expr
assignSimple :: VarName -> Expr -> Statement
assignAt :: VarName -> Expr -> Expr -> Statement
callFunction :: FunName -> [Type] -> [Expr] -> Expr
callFunction' :: FunName -> [Type] -> [Expr] -> Statement
callMethod :: Expr -> FunName -> [Expr] -> Expr
callMethod' :: Expr -> FunName -> [Expr] -> Statement
vecCtor :: Type -> [Expr] -> Expr
begin :: Expr -> Expr
end :: Expr -> Expr
mapExprStatementExprM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> Expr -> m Expr
mapExprStatementLeftExprM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> LeftExpr -> m LeftExpr
mapExprStatementAssignExprM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> AssignExpr -> m AssignExpr
mapExprStatementStatementM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> Statement -> m Statement
mapExprStatementToplevelStatementM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> ToplevelStatement -> m ToplevelStatement
mapExprStatementProgramM :: Monad m => (Expr -> m Expr) -> (Statement -> m Statement) -> Program -> m Program
mapExprStatementProgram :: (Expr -> Expr) -> (Statement -> Statement) -> Program -> Program
replaceExpr :: VarName -> Expr -> Expr -> Expr
replaceStatement :: VarName -> Expr -> Statement -> Statement
instance GHC.Read.Read Jikka.CPlusPlus.Language.Util.NameKind
instance GHC.Show.Show Jikka.CPlusPlus.Language.Util.NameKind
instance GHC.Classes.Ord Jikka.CPlusPlus.Language.Util.NameKind
instance GHC.Classes.Eq Jikka.CPlusPlus.Language.Util.NameKind

module Jikka.Common.Combinatorics
fact :: Integral a => a -> a
choose :: Integral a => a -> a -> a
permute :: Integral a => a -> a -> a
multichoose :: Integral a => a -> a -> a

module Jikka.Common.FileEmbed
listDirectoryRecursive :: FilePath -> IO [FilePath]

-- | <a>embedDir</a> find files recursively and embed their contents, like
--   <a>https://hackage.haskell.org/package/file-embed</a>
--   <tt>file-embed</tt>&gt;'s <a>@embedDir@</a>.
--   
--   <h2>Usage</h2>
--   
--   <pre>
--   myDir :: [(FilePath, Data.Text.Text)]
--   myDir = $(embedDir "dirName")
--   </pre>
embedDir :: FilePath -> Q Exp

module Jikka.Common.Format.AutoIndent
indent :: String
dedent :: String
makeIndentFromMarkers :: Int -> [String] -> [String]
makeIndentFromBraces :: Int -> [String] -> [String]
insertIndentDedentFromBraces :: [String] -> [String]


-- | <a>Format</a> module converts the AST for C++ to the plain source
--   code.
module Jikka.CPlusPlus.Format
run :: Applicative m => Program -> m Text
run' :: Program -> String
type Code = String
formatExpr :: Expr -> (Code, Prec)
formatType :: Type -> Code
instance GHC.Read.Read Jikka.CPlusPlus.Format.Prec
instance GHC.Show.Show Jikka.CPlusPlus.Format.Prec
instance GHC.Classes.Ord Jikka.CPlusPlus.Format.Prec
instance GHC.Classes.Eq Jikka.CPlusPlus.Format.Prec
instance GHC.Read.Read Jikka.CPlusPlus.Format.Assoc
instance GHC.Show.Show Jikka.CPlusPlus.Format.Assoc
instance GHC.Classes.Ord Jikka.CPlusPlus.Format.Assoc
instance GHC.Classes.Eq Jikka.CPlusPlus.Format.Assoc

module Jikka.Common.Format.Color
data ColorFlag
EnableColor :: ColorFlag
DisableColor :: ColorFlag
withColor :: ColorFlag -> Color -> String -> String
withBold :: ColorFlag -> String -> String
hGetColorFlag :: Handle -> IO ColorFlag

-- | ANSI's eight standard colors. They come in two intensities, which are
--   controlled by <a>ColorIntensity</a>. Many terminals allow the colors
--   of the standard palette to be customised, so that, for example,
--   <tt>setSGR [ SetColor Foreground Vivid Green ]</tt> may not result in
--   bright green characters.
data Color
Black :: Color
Red :: Color
Green :: Color
Yellow :: Color
Blue :: Color
Magenta :: Color
Cyan :: Color
White :: Color
instance GHC.Read.Read Jikka.Common.Format.Color.ColorFlag
instance GHC.Show.Show Jikka.Common.Format.Color.ColorFlag
instance GHC.Classes.Ord Jikka.Common.Format.Color.ColorFlag
instance GHC.Classes.Eq Jikka.Common.Format.Color.ColorFlag

module Jikka.Common.Format.Show
run :: Show program => program -> Either String Text

module Jikka.Common.Graph
type Graph = Vector [Int]
makeReversedDigraph :: Graph -> Graph
makeInducedDigraph :: Graph -> Vector Int -> Graph

-- | <a>decomposeToStronglyConnectedComponents</a> does SCC in &lt;math&gt;
--   using Kosaraju's algorithm. It takes a digraph &lt;math&gt; as an
--   adjacent list &lt;math&gt;, and returns an mapping &lt;math&gt; for
--   the SCC DAG &lt;math&gt;. The indices of vertices of the SCC DAG are
--   topologically sorted.
decomposeToStronglyConnectedComponents :: Graph -> Vector Int

-- | <a>topologicalSort</a> does topological sort in &lt;math&gt; using
--   Tarjan's algorithm. The input is an adjacent list of a DAG.
topologicalSort :: Graph -> Vector Int

module Jikka.Common.IO
hTakeWhile :: Handle -> (Char -> Bool) -> IO String
hGetWord :: Handle -> IO String
getWord :: IO String

module Jikka.Common.Location

-- | <a>Loc</a> represents a location of something in the users' source
--   code. <a>line</a> and <a>column</a> is 1-based.
data Loc
Loc :: !Int -> !Int -> !Int -> Loc
[line] :: Loc -> !Int
[column] :: Loc -> !Int
[width] :: Loc -> !Int
data WithLoc a
WithLoc :: !Loc -> !a -> WithLoc a
[loc] :: WithLoc a -> !Loc
[value] :: WithLoc a -> !a
data WithLoc' a
WithLoc' :: !Maybe Loc -> !a -> WithLoc' a
[loc'] :: WithLoc' a -> !Maybe Loc
[value'] :: WithLoc' a -> !a
withoutLoc :: a -> WithLoc' a
instance GHC.Read.Read Jikka.Common.Location.Loc
instance GHC.Show.Show Jikka.Common.Location.Loc
instance GHC.Classes.Ord Jikka.Common.Location.Loc
instance GHC.Classes.Eq Jikka.Common.Location.Loc
instance GHC.Base.Functor Jikka.Common.Location.WithLoc
instance GHC.Read.Read a => GHC.Read.Read (Jikka.Common.Location.WithLoc a)
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Location.WithLoc a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Location.WithLoc a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Location.WithLoc a)
instance GHC.Base.Functor Jikka.Common.Location.WithLoc'
instance GHC.Read.Read a => GHC.Read.Read (Jikka.Common.Location.WithLoc' a)
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Location.WithLoc' a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Location.WithLoc' a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Location.WithLoc' a)
instance Data.String.IsString a => Data.String.IsString (Jikka.Common.Location.WithLoc' a)

module Jikka.Common.Format.Location
prettyLoc :: Loc -> String
prettyLocWithText :: ColorFlag -> Text -> Loc -> [String]


module Jikka.Common.Error
data Responsibility
UserMistake :: Responsibility
ImplementationBug :: Responsibility
data ErrorGroup

-- | It's impossible to split the given source text into tokens.
LexicalError :: ErrorGroup

-- | It's impossible to construct AST from tokens.
SyntaxError :: ErrorGroup

-- | There are undefined variables or functions in AST.
SymbolError :: ErrorGroup

-- | It's impossible reconstruct types for AST.
TypeError :: ErrorGroup

-- | other semantic erros
SemanticError :: ErrorGroup

-- | User's program are not ready to evaluate.
EvaluationError :: ErrorGroup

-- | User's program failed while running.
RuntimeError :: ErrorGroup

-- | User's program violates its assertion.
AssertionError :: ErrorGroup

-- | The given command line arguments are not acceptable.
CommandLineError :: ErrorGroup

-- | User's program was correctly running but wrong input text is given.
WrongInputError :: ErrorGroup

-- | It's an bug of implementation.
InternalError :: ErrorGroup
data Error
Error :: String -> Error
ErrorAppend :: Error -> Error -> Error
WithGroup :: ErrorGroup -> Error -> Error
WithWrapped :: String -> Error -> Error
WithLocation :: Loc -> Error -> Error
WithResponsibility :: Responsibility -> Error -> Error
wrapError :: MonadError e m => (e -> e) -> m a -> m a
wrapError' :: MonadError Error m => String -> m a -> m a
wrapAt :: MonadError Error m => Loc -> m a -> m a
wrapAt' :: MonadError Error m => Maybe Loc -> m a -> m a
maybeToError :: MonadError a m => a -> Maybe b -> m b
eitherToError :: MonadError a m => Either a b -> m b

-- | <a>catchError</a>` is the inverse of <tt>liftError</tt>.
catchError' :: MonadError e m => m a -> m (Either e a)
reportErrors :: MonadError Error m => [Either Error a] -> m [a]
reportErrors2 :: MonadError Error m => Either Error a -> Either Error b -> m (a, b)
reportErrors3 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> m (a, b, c)
reportErrors4 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> Either Error d -> m (a, b, c, d)
reportErrors5 :: MonadError Error m => Either Error a -> Either Error b -> Either Error c -> Either Error d -> Either Error e -> m (a, b, c, d, e)
lexicalError :: String -> Error
lexicalErrorAt :: Loc -> String -> Error
syntaxError :: String -> Error
syntaxErrorAt :: Loc -> String -> Error
symbolError :: String -> Error
symbolErrorAt :: Loc -> String -> Error
typeError :: String -> Error
semanticError :: String -> Error
evaluationError :: String -> Error
runtimeError :: String -> Error
assertionError :: String -> Error
commandLineError :: String -> Error
wrongInputError :: String -> Error
internalError :: String -> Error
throwLexicalError :: MonadError Error m => String -> m a
throwLexicalErrorAt :: MonadError Error m => Loc -> String -> m a
throwSyntaxError :: MonadError Error m => String -> m a
throwSyntaxErrorAt :: MonadError Error m => Loc -> String -> m a
throwSyntaxErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
throwSymbolError :: MonadError Error m => String -> m a
throwSymbolErrorAt :: MonadError Error m => Loc -> String -> m a
throwSymbolErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
throwTypeError :: MonadError Error m => String -> m a
throwTypeErrorAt :: MonadError Error m => Loc -> String -> m a
throwTypeErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
throwSemanticError :: MonadError Error m => String -> m a
throwSemanticErrorAt :: MonadError Error m => Loc -> String -> m a
throwSemanticErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
throwEvaluationError :: MonadError Error m => String -> m a
throwRuntimeError :: MonadError Error m => String -> m a
throwRuntimeErrorAt :: MonadError Error m => Loc -> String -> m a
throwRuntimeErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
throwAssertionError :: MonadError Error m => String -> m a
throwCommandLineError :: MonadError Error m => String -> m a
throwWrongInputError :: MonadError Error m => String -> m a
throwInternalError :: MonadError Error m => String -> m a
throwInternalErrorAt :: MonadError Error m => Loc -> String -> m a
throwInternalErrorAt' :: MonadError Error m => Maybe Loc -> String -> m a
bug :: String -> a
todo :: String -> a
instance GHC.Read.Read Jikka.Common.Error.Responsibility
instance GHC.Show.Show Jikka.Common.Error.Responsibility
instance GHC.Classes.Ord Jikka.Common.Error.Responsibility
instance GHC.Classes.Eq Jikka.Common.Error.Responsibility
instance GHC.Read.Read Jikka.Common.Error.ErrorGroup
instance GHC.Show.Show Jikka.Common.Error.ErrorGroup
instance GHC.Classes.Ord Jikka.Common.Error.ErrorGroup
instance GHC.Classes.Eq Jikka.Common.Error.ErrorGroup
instance GHC.Read.Read Jikka.Common.Error.Error
instance GHC.Show.Show Jikka.Common.Error.Error
instance GHC.Classes.Ord Jikka.Common.Error.Error
instance GHC.Classes.Eq Jikka.Common.Error.Error
instance GHC.Base.Semigroup Jikka.Common.Error.Error

module Jikka.Common.IOFormat
data FormatExpr
Var :: String -> FormatExpr
Plus :: FormatExpr -> Integer -> FormatExpr
At :: FormatExpr -> String -> FormatExpr
Len :: FormatExpr -> FormatExpr
data FormatTree
Exp :: FormatExpr -> FormatTree
Newline :: FormatTree
Seq :: [FormatTree] -> FormatTree
Loop :: String -> FormatExpr -> FormatTree -> FormatTree
data IOFormat
IOFormat :: [String] -> FormatTree -> Either String [String] -> FormatTree -> IOFormat
[inputVariables] :: IOFormat -> [String]
[inputTree] :: IOFormat -> FormatTree

-- | This uses <a>Either</a> to distinguish a type and the 1-tuple of it.
[outputVariables] :: IOFormat -> Either String [String]
[outputTree] :: IOFormat -> FormatTree
mapFormatTreeM :: Monad m => (FormatTree -> m FormatTree) -> FormatTree -> m FormatTree
mapFormatTree :: (FormatTree -> FormatTree) -> FormatTree -> FormatTree
normalizeFormatTree :: FormatTree -> FormatTree
normalizeIOFormat :: IOFormat -> IOFormat
hasNewline :: FormatTree -> Bool
formatFormatExpr :: FormatExpr -> String
formatFormatTree :: FormatTree -> String
formatIOFormat :: IOFormat -> String
packSubscriptedVar :: String -> [String] -> FormatExpr
packSubscriptedVar' :: String -> [String] -> FormatTree
unpackSubscriptedVar :: MonadError Error m => FormatExpr -> m (String, [String])
makeReadValueIO :: (MonadError Error m, MonadIO m) => (value -> m Integer) -> (Integer -> value) -> (value -> m (Vector value)) -> (Vector value -> value) -> IOFormat -> m ([value], Map String value)
makeWriteValueIO :: (MonadError Error m, MonadIO m) => (value -> m [value]) -> (Integer -> value) -> (value -> m Integer) -> (value -> m (Vector value)) -> IOFormat -> Map String value -> value -> m ()
instance GHC.Show.Show Jikka.Common.IOFormat.FormatExpr
instance GHC.Read.Read Jikka.Common.IOFormat.FormatExpr
instance GHC.Classes.Ord Jikka.Common.IOFormat.FormatExpr
instance GHC.Classes.Eq Jikka.Common.IOFormat.FormatExpr
instance GHC.Show.Show Jikka.Common.IOFormat.FormatTree
instance GHC.Read.Read Jikka.Common.IOFormat.FormatTree
instance GHC.Classes.Ord Jikka.Common.IOFormat.FormatTree
instance GHC.Classes.Eq Jikka.Common.IOFormat.FormatTree
instance GHC.Show.Show Jikka.Common.IOFormat.IOFormat
instance GHC.Read.Read Jikka.Common.IOFormat.IOFormat
instance GHC.Classes.Ord Jikka.Common.IOFormat.IOFormat
instance GHC.Classes.Eq Jikka.Common.IOFormat.IOFormat

module Jikka.Common.Format.Error
prettyError :: ColorFlag -> Error -> [String]
prettyError' :: Error -> [String]
prettyErrorWithText :: ColorFlag -> Text -> Error -> [String]
hPrintError :: Handle -> Error -> IO ()
hPrintErrorWithText :: Handle -> Text -> Error -> IO ()


module Jikka.CPlusPlus.Convert.UseInitialization

-- | <a>run</a> unpack tuples.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   vector&lt;int&gt; xs = vector&lt;int&gt;(n, 0);
--   </pre>
--   
--   After:
--   
--   <pre>
--   vector&lt;int&gt; xs(n, 0);
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.CPlusPlus.Convert.UnpackTuples

-- | <a>run</a> unpack tuples.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   tuple&lt;int, int&gt; c = make_tuple(a, b);
--   func(get&lt;0&gt;(c), get&lt;1&gt;(c));
--   </pre>
--   
--   After:
--   
--   <pre>
--   int c0 = a;
--   int c1 = b;
--   func(c0, c1);
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.CPlusPlus.Convert.OptimizeRange

-- | <a>run</a> replaces superfluous copying.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   int b = range(a).size();
--   </pre>
--   
--   After:
--   
--   <pre>
--   int b = a;
--   </pre>
--   
--   Before:
--   
--   <pre>
--   for (int i : jikka::range(n)) {
--       ...
--   }
--   </pre>
--   
--   After:
--   
--   <pre>
--   for (int i = 0; i &lt; n; ++ i) {
--       ...
--   }
--   </pre>
run :: MonadError Error m => Program -> m Program


module Jikka.CPlusPlus.Convert.MoveSemantics

-- | <a>run</a> replaces superfluous copying.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   vector&lt;int&gt; solve(vector&lt;int&gt; a) {
--       vector&lt;int&gt; b = a;
--       b[0] = 1;
--       return b;
--   }
--   </pre>
--   
--   After:
--   
--   <pre>
--   vector&lt;int&gt; solve(vector&lt;int&gt; a) {
--       a[0] = 1;
--       return a;
--   }
--   </pre>
--   
--   Before:
--   
--   <pre>
--   int solve(int a, int b, int x) {
--       jikka::convex_hull_trick cht = jikka::convex_hull_trick();
--       cht = jikka::convex_hull_trick::persistent_add_line(cht, a, b);
--       return cht.get_min(x);
--   }
--   </pre>
--   
--   After:
--   
--   <pre>
--   int solve(int a, int b, int x) {
--       jikka::convex_hull_trick cht;
--       cht = cht.add_line(a, b);
--       return cht.get_min(x);
--   }
--   </pre>
run :: MonadError Error m => Program -> m Program


module Jikka.CPlusPlus.Convert.AddMain
run :: (MonadAlpha m, MonadError Error m) => Program -> IOFormat -> m Program

module Jikka.Common.Matrix

-- | <a>Matrix</a> is data for matrices. It is guaranteed that internal
--   arrays are not jagged arrays.
data Matrix a
unMatrix :: Matrix a -> Vector (Vector a)
makeMatrix :: Vector (Vector a) -> Maybe (Matrix a)
makeMatrix' :: Vector (Vector a) -> Matrix a

-- | <a>matsize</a> computes the size of a matrix.
matsize :: Matrix a -> (Int, Int)

-- | <a>matsize</a>` computes the size of a matrix. This assumes inputs are
--   matrices (<a>matcheck</a>).
matsize' :: Vector (Vector a) -> (Int, Int)

-- | <a>matcheck</a> checks a given vector of vectors is a matrix. That is,
--   this returns <a>False</a> for jagged arrays.
matcheck :: Vector (Vector a) -> Bool
matzero :: Num a => Int -> Matrix a
matone :: Num a => Int -> Matrix a

-- | <a>matadd</a> calculates the addition &lt;math&gt; of two matrices
--   &lt;math&gt;. This assumes sizes of inputs match.
matadd :: Num a => Matrix a -> Matrix a -> Matrix a

-- | <a>matmul</a> calculates the multiplication &lt;math&gt;of two
--   matrices &lt;math&gt;. This assumes sizes of inputs match.
matmul :: Num a => Matrix a -> Matrix a -> Matrix a

-- | <a>matap</a> calculates the multiplication &lt;math&gt; of a matrix
--   &lt;math&gt; and a vector &lt;math&gt;. This assumes sizes of inputs
--   match.
matap :: Num a => Matrix a -> Vector a -> Vector a
matscalar :: Num a => a -> Matrix a -> Matrix a

-- | <a>matpow</a> calculates the power &lt;math&gt; of a matrix
--   &lt;math&gt; and a natural number &lt;math&gt;. This assumes inputs
--   are square matrices. This fails for &lt;math&gt;.
matpow :: (Show a, Num a) => Matrix a -> Integer -> Matrix a
instance GHC.Base.Functor Jikka.Common.Matrix.Matrix
instance GHC.Show.Show a => GHC.Show.Show (Jikka.Common.Matrix.Matrix a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Jikka.Common.Matrix.Matrix a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Jikka.Common.Matrix.Matrix a)

module Jikka.Common.ModInt
data ModInt
toModInt :: Integer -> Integer -> ModInt
fromModInt :: ModInt -> Integer
moduloOfModInt :: ModInt -> Maybe Integer
instance GHC.Show.Show Jikka.Common.ModInt.ModInt
instance GHC.Read.Read Jikka.Common.ModInt.ModInt
instance GHC.Classes.Ord Jikka.Common.ModInt.ModInt
instance GHC.Classes.Eq Jikka.Common.ModInt.ModInt
instance GHC.Num.Num Jikka.Common.ModInt.ModInt

module Jikka.Common.Parse.JoinLines
joinLinesWithParens :: forall m a. (MonadError Error m, Show a) => (a -> Bool) -> (a -> Bool) -> (a -> Bool) -> [WithLoc a] -> m [WithLoc a]
removeEmptyLines :: forall a. (a -> Bool) -> [WithLoc a] -> [WithLoc a]

module Jikka.Common.Parse.OffsideRule

-- | <a>insertIndents</a> inserts <tt>INDENT</tt> and <tt>DEDENT</tt>
--   tokens with Python's way
--   (<a>https://docs.python.org/3/reference/lexical_analysis.html#indentation</a>).
--   The <a>column</a> of <a>Loc</a> must be 1-based. This doen't use
--   physical <a>line</a> of <a>Loc</a> because logical lines are used for
--   indentation.
insertIndents :: forall m a. (MonadError Error m, Show a) => a -> a -> (a -> Bool) -> [WithLoc a] -> m [WithLoc a]

module Jikka.Common.Parse.Read
run :: Read program => FilePath -> Text -> Either String program

module Jikka.Common.Parse.ShuntingYard
run :: forall m op expr. MonadError Error m => (op -> m BinOpInfo) -> (WithLoc op -> WithLoc expr -> WithLoc expr -> WithLoc expr) -> (WithLoc expr, [(WithLoc op, WithLoc expr)]) -> m (WithLoc expr)
type Prec = Int
data Fixity
Leftfix :: Fixity
Rightfix :: Fixity
Nonfix :: Fixity
data BinOpInfo
BinOpInfo :: Fixity -> Prec -> BinOpInfo
instance GHC.Read.Read Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Show.Show Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Enum.Bounded Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Enum.Enum Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Classes.Ord Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Classes.Eq Jikka.Common.Parse.ShuntingYard.Fixity
instance GHC.Read.Read Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Show.Show Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Classes.Ord Jikka.Common.Parse.ShuntingYard.BinOpInfo
instance GHC.Classes.Eq Jikka.Common.Parse.ShuntingYard.BinOpInfo


-- | <a>Expr</a> module has the basic data types for our core language.
--   They are similar to the GHC Core language.
module Jikka.Core.Language.Expr
newtype VarName
VarName :: String -> VarName
unVarName :: VarName -> String
newtype TypeName
TypeName :: String -> TypeName
unTypeName :: TypeName -> String

-- | <a>Type</a> represents the types of our core language. This is similar
--   to the <a>Type</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>type-type</a>.
--   
--   &lt;math&gt;
data Type
VarTy :: TypeName -> Type
IntTy :: Type
BoolTy :: Type
ListTy :: Type -> Type
TupleTy :: [Type] -> Type
FunTy :: Type -> Type -> Type
DataStructureTy :: DataStructure -> Type
data DataStructure
ConvexHullTrick :: DataStructure
SegmentTree :: Semigroup' -> DataStructure
data Semigroup'
SemigroupIntPlus :: Semigroup'
SemigroupIntMin :: Semigroup'
SemigroupIntMax :: Semigroup'

-- | TODO: What is the difference between <a>Literal</a> and
--   <a>Builtin</a>?
data Builtin

-- | &lt;math&gt;
Negate :: Builtin

-- | &lt;math&gt;
Plus :: Builtin

-- | &lt;math&gt;
Minus :: Builtin

-- | &lt;math&gt;
Mult :: Builtin

-- | &lt;math&gt;
FloorDiv :: Builtin

-- | &lt;math&gt;
FloorMod :: Builtin

-- | &lt;math&gt;
CeilDiv :: Builtin

-- | &lt;math&gt;
CeilMod :: Builtin

-- | &lt;math&gt;
Pow :: Builtin

-- | &lt;math&gt;
Abs :: Builtin

-- | &lt;math&gt;
Gcd :: Builtin

-- | &lt;math&gt;
Lcm :: Builtin

-- | &lt;math&gt;
Min2 :: Builtin

-- | &lt;math&gt;
Max2 :: Builtin

-- | iterated application &lt;math&gt;
Iterate :: Builtin

-- | &lt;math&gt;
Not :: Builtin

-- | &lt;math&gt;
And :: Builtin

-- | &lt;math&gt;
Or :: Builtin

-- | &lt;math&gt;
Implies :: Builtin

-- | &lt;math&gt;
If :: Builtin

-- | &lt;math&gt;
BitNot :: Builtin

-- | &lt;math&gt;
BitAnd :: Builtin

-- | &lt;math&gt;
BitOr :: Builtin

-- | &lt;math&gt;
BitXor :: Builtin

-- | &lt;math&gt;
BitLeftShift :: Builtin

-- | &lt;math&gt;
BitRightShift :: Builtin

-- | matrix application &lt;math&gt;
MatAp :: Integer -> Integer -> Builtin

-- | zero matrix &lt;math&gt;
MatZero :: Integer -> Builtin

-- | unit matrix &lt;math&gt;
MatOne :: Integer -> Builtin

-- | matrix addition &lt;math&gt;
MatAdd :: Integer -> Integer -> Builtin

-- | matrix multiplication &lt;math&gt;
MatMul :: Integer -> Integer -> Integer -> Builtin

-- | matrix power &lt;math&gt;
MatPow :: Integer -> Builtin

-- | vector point-wise floor-mod &lt;math&gt;
VecFloorMod :: Integer -> Builtin

-- | matrix point-wise floor-mod &lt;math&gt;
MatFloorMod :: Integer -> Integer -> Builtin

-- | &lt;math&gt;
ModNegate :: Builtin

-- | &lt;math&gt;
ModPlus :: Builtin

-- | &lt;math&gt;
ModMinus :: Builtin

-- | &lt;math&gt;
ModMult :: Builtin

-- | &lt;math&gt;
ModInv :: Builtin

-- | &lt;math&gt;
ModPow :: Builtin

-- | matrix application &lt;math&gt;
ModMatAp :: Integer -> Integer -> Builtin

-- | matrix addition &lt;math&gt;
ModMatAdd :: Integer -> Integer -> Builtin

-- | matrix multiplication &lt;math&gt;
ModMatMul :: Integer -> Integer -> Integer -> Builtin

-- | matrix power &lt;math&gt;
ModMatPow :: Integer -> Builtin

-- | &lt;math&gt;
Cons :: Builtin

-- | &lt;math&gt;
Snoc :: Builtin

-- | &lt;math&gt;
Foldl :: Builtin

-- | &lt;math&gt;
Scanl :: Builtin

-- | &lt;math&gt; repeat <tt>a &lt;- snoc a (f a)</tt> <tt>n</tt> times
--   &lt;math&gt;
Build :: Builtin

-- | &lt;math&gt;
Len :: Builtin

-- | &lt;math&gt;
Map :: Builtin

-- | &lt;math&gt;
Filter :: Builtin

-- | &lt;math&gt;
At :: Builtin

-- | &lt;math&gt;
SetAt :: Builtin

-- | &lt;math&gt;
Elem :: Builtin

-- | &lt;math&gt;
Sum :: Builtin

-- | &lt;math&gt;
Product :: Builtin

-- | &lt;math&gt;
ModSum :: Builtin

-- | &lt;math&gt;
ModProduct :: Builtin

-- | &lt;math&gt;
Min1 :: Builtin

-- | &lt;math&gt;
Max1 :: Builtin

-- | &lt;math&gt;
ArgMin :: Builtin

-- | &lt;math&gt;
ArgMax :: Builtin

-- | &lt;math&gt;
All :: Builtin

-- | &lt;math&gt;
Any :: Builtin

-- | &lt;math&gt;
Sorted :: Builtin

-- | &lt;math&gt;
Reversed :: Builtin

-- | &lt;math&gt;
Range1 :: Builtin

-- | &lt;math&gt;
Range2 :: Builtin

-- | &lt;math&gt;
Range3 :: Builtin

-- | &lt;math&gt;
Tuple :: Builtin

-- | &lt;math&gt;
Proj :: Integer -> Builtin

-- | &lt;math&gt;
LessThan :: Builtin

-- | &lt;math&gt;
LessEqual :: Builtin

-- | &lt;math&gt;
GreaterThan :: Builtin

-- | &lt;math&gt;
GreaterEqual :: Builtin

-- | &lt;math&gt;
Equal :: Builtin

-- | &lt;math&gt;
NotEqual :: Builtin

-- | &lt;math&gt;
Fact :: Builtin

-- | &lt;math&gt;
Choose :: Builtin

-- | &lt;math&gt;
Permute :: Builtin

-- | &lt;math&gt;
MultiChoose :: Builtin

-- | &lt;math&gt;
ConvexHullTrickInit :: Builtin

-- | &lt;math&gt;
ConvexHullTrickGetMin :: Builtin

-- | &lt;math&gt;
ConvexHullTrickInsert :: Builtin

-- | &lt;math&gt;
SegmentTreeInitList :: Semigroup' -> Builtin

-- | &lt;math&gt;
SegmentTreeGetRange :: Semigroup' -> Builtin

-- | &lt;math&gt;
SegmentTreeSetPoint :: Semigroup' -> Builtin
data Literal
LitBuiltin :: Builtin -> [Type] -> Literal

-- | &lt;math&gt;
LitInt :: Integer -> Literal

-- | &lt;math&gt;
LitBool :: Bool -> Literal

-- | &lt;math&gt;
LitNil :: Type -> Literal

-- | &lt;math&gt;. The second argument is its error message.
LitBottom :: Type -> String -> Literal

-- | <a>Expr</a> represents the exprs of our core language. This is similar
--   to the <a>Expr</a> of GHC Core. See also
--   <a>commentary<i>compiler</i>core-syn-type</a>.
--   
--   &lt;math&gt;
data Expr
Var :: VarName -> Expr
Lit :: Literal -> Expr

-- | The functions are not curried.
App :: Expr -> Expr -> Expr

-- | The lambdas are also not curried.
Lam :: VarName -> Type -> Expr -> Expr

-- | This "let" is not recursive.
Let :: VarName -> Type -> Expr -> Expr -> Expr
pattern Fun2Ty :: Type -> Type -> Type -> Type
pattern Fun3Ty :: Type -> Type -> Type -> Type -> Type
pattern Fun1STy :: Type -> Type
pattern Fun2STy :: Type -> Type
pattern Fun3STy :: Type -> Type
pattern FunLTy :: Type -> Type
vectorTy :: Integer -> Type
matrixTy :: Integer -> Integer -> Type
pattern UnitTy :: Type
pattern ConvexHullTrickTy :: Type
pattern SegmentTreeTy :: Semigroup' -> Type
pattern LitInt' :: Integer -> Expr
pattern Lit0 :: Expr
pattern Lit1 :: Expr
pattern Lit2 :: Expr
pattern LitMinus1 :: Expr
pattern LitBool' :: Bool -> Expr
pattern LitTrue :: Expr
pattern LitFalse :: Expr
pattern Builtin :: Builtin -> Expr
pattern Builtin1 :: Builtin -> Type -> Expr
pattern Builtin2 :: Builtin -> Type -> Type -> Expr
pattern App2 :: Expr -> Expr -> Expr -> Expr
pattern App3 :: Expr -> Expr -> Expr -> Expr -> Expr
pattern App4 :: Expr -> Expr -> Expr -> Expr -> Expr -> Expr
pattern AppBuiltin1 :: Builtin -> Expr -> Expr
pattern AppBuiltin11 :: Builtin -> Type -> Expr -> Expr
pattern AppBuiltin2 :: Builtin -> Expr -> Expr -> Expr
pattern AppBuiltin12 :: Builtin -> Type -> Expr -> Expr -> Expr
pattern AppBuiltin22 :: Builtin -> Type -> Type -> Expr -> Expr -> Expr
pattern AppBuiltin3 :: Builtin -> Expr -> Expr -> Expr -> Expr
pattern AppBuiltin13 :: Builtin -> Type -> Expr -> Expr -> Expr -> Expr
pattern AppBuiltin23 :: Builtin -> Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern AppBuiltin14 :: Builtin -> Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern Lam2 :: VarName -> Type -> VarName -> Type -> Expr -> Expr
pattern Lam3 :: VarName -> Type -> VarName -> Type -> VarName -> Type -> Expr -> Expr

-- | <a>ToplevelExpr</a> is the toplevel exprs. In our core, "let rec" is
--   allowed only on the toplevel.
--   
--   &lt;math&gt;
data ToplevelExpr
ResultExpr :: Expr -> ToplevelExpr
ToplevelLet :: VarName -> Type -> Expr -> ToplevelExpr -> ToplevelExpr
ToplevelLetRec :: VarName -> [(VarName, Type)] -> Type -> Expr -> ToplevelExpr -> ToplevelExpr
type Program = ToplevelExpr
instance Data.String.IsString Jikka.Core.Language.Expr.VarName
instance Data.Data.Data Jikka.Core.Language.Expr.VarName
instance GHC.Read.Read Jikka.Core.Language.Expr.VarName
instance GHC.Show.Show Jikka.Core.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.Core.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.Core.Language.Expr.VarName
instance Data.String.IsString Jikka.Core.Language.Expr.TypeName
instance Data.Data.Data Jikka.Core.Language.Expr.TypeName
instance GHC.Read.Read Jikka.Core.Language.Expr.TypeName
instance GHC.Show.Show Jikka.Core.Language.Expr.TypeName
instance GHC.Classes.Ord Jikka.Core.Language.Expr.TypeName
instance GHC.Classes.Eq Jikka.Core.Language.Expr.TypeName
instance Data.Data.Data Jikka.Core.Language.Expr.Semigroup'
instance GHC.Read.Read Jikka.Core.Language.Expr.Semigroup'
instance GHC.Show.Show Jikka.Core.Language.Expr.Semigroup'
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Semigroup'
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Semigroup'
instance Data.Data.Data Jikka.Core.Language.Expr.DataStructure
instance GHC.Read.Read Jikka.Core.Language.Expr.DataStructure
instance GHC.Show.Show Jikka.Core.Language.Expr.DataStructure
instance GHC.Classes.Ord Jikka.Core.Language.Expr.DataStructure
instance GHC.Classes.Eq Jikka.Core.Language.Expr.DataStructure
instance Data.Data.Data Jikka.Core.Language.Expr.Type
instance GHC.Read.Read Jikka.Core.Language.Expr.Type
instance GHC.Show.Show Jikka.Core.Language.Expr.Type
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Type
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Type
instance Data.Data.Data Jikka.Core.Language.Expr.Builtin
instance GHC.Read.Read Jikka.Core.Language.Expr.Builtin
instance GHC.Show.Show Jikka.Core.Language.Expr.Builtin
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Builtin
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Builtin
instance Data.Data.Data Jikka.Core.Language.Expr.Literal
instance GHC.Read.Read Jikka.Core.Language.Expr.Literal
instance GHC.Show.Show Jikka.Core.Language.Expr.Literal
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Literal
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Literal
instance Data.Data.Data Jikka.Core.Language.Expr.Expr
instance GHC.Read.Read Jikka.Core.Language.Expr.Expr
instance GHC.Show.Show Jikka.Core.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.Core.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.Core.Language.Expr.Expr
instance Data.Data.Data Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Read.Read Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Show.Show Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Classes.Ord Jikka.Core.Language.Expr.ToplevelExpr
instance GHC.Classes.Eq Jikka.Core.Language.Expr.ToplevelExpr


-- | <a>BuiltinPatterns</a> provides pattern synonyms for applications of
--   <a>Builtin</a> functions. For example, provide a pattern <tt>Sum'
--   e</tt> which is interpreted as <tt>AppBuiltin1 Sum [e]</tt>, or the
--   same thing, <tt>App (Lit (LitBuiltin Sum)) [e]</tt>.
module Jikka.Core.Language.BuiltinPatterns
pattern Negate' :: Expr -> Expr
pattern Plus' :: Expr -> Expr -> Expr
pattern Minus' :: Expr -> Expr -> Expr
pattern Mult' :: Expr -> Expr -> Expr
pattern FloorDiv' :: Expr -> Expr -> Expr
pattern FloorMod' :: Expr -> Expr -> Expr
pattern CeilDiv' :: Expr -> Expr -> Expr
pattern CeilMod' :: Expr -> Expr -> Expr
pattern Pow' :: Expr -> Expr -> Expr
pattern Abs' :: Expr -> Expr
pattern Gcd' :: Expr -> Expr -> Expr
pattern Lcm' :: Expr -> Expr -> Expr
pattern Min2' :: Type -> Expr -> Expr -> Expr
pattern Max2' :: Type -> Expr -> Expr -> Expr
pattern Iterate' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Not' :: Expr -> Expr
pattern And' :: Expr -> Expr -> Expr
pattern Or' :: Expr -> Expr -> Expr
pattern Implies' :: Expr -> Expr -> Expr
pattern If' :: Type -> Expr -> Expr -> Expr -> Expr
pattern BitNot' :: Expr -> Expr
pattern BitAnd' :: Expr -> Expr -> Expr
pattern BitOr' :: Expr -> Expr -> Expr
pattern BitXor' :: Expr -> Expr -> Expr
pattern BitLeftShift' :: Expr -> Expr -> Expr
pattern BitRightShift' :: Expr -> Expr -> Expr
pattern MatAp' :: Integer -> Integer -> Expr -> Expr -> Expr
pattern MatAdd' :: Integer -> Integer -> Expr -> Expr -> Expr
pattern MatMul' :: Integer -> Integer -> Integer -> Expr -> Expr -> Expr
pattern MatPow' :: Integer -> Expr -> Expr -> Expr
pattern VecFloorMod' :: Integer -> Expr -> Expr -> Expr
pattern MatFloorMod' :: Integer -> Integer -> Expr -> Expr -> Expr
pattern ModNegate' :: Expr -> Expr -> Expr
pattern ModPlus' :: Expr -> Expr -> Expr -> Expr
pattern ModMinus' :: Expr -> Expr -> Expr -> Expr
pattern ModMult' :: Expr -> Expr -> Expr -> Expr
pattern ModInv' :: Expr -> Expr -> Expr
pattern ModPow' :: Expr -> Expr -> Expr -> Expr
pattern ModMatAp' :: Integer -> Integer -> Expr -> Expr -> Expr -> Expr
pattern ModMatAdd' :: Integer -> Integer -> Expr -> Expr -> Expr -> Expr
pattern ModMatMul' :: Integer -> Integer -> Integer -> Expr -> Expr -> Expr -> Expr
pattern ModMatPow' :: Integer -> Expr -> Expr -> Expr -> Expr
pattern Nil' :: Type -> Expr
pattern Cons' :: Type -> Expr -> Expr -> Expr
pattern Snoc' :: Type -> Expr -> Expr -> Expr
pattern Foldl' :: Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern Scanl' :: Type -> Type -> Expr -> Expr -> Expr -> Expr
pattern Build' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Len' :: Type -> Expr -> Expr
pattern Map' :: Type -> Type -> Expr -> Expr -> Expr
pattern Filter' :: Type -> Expr -> Expr -> Expr
pattern At' :: Type -> Expr -> Expr -> Expr
pattern SetAt' :: Type -> Expr -> Expr -> Expr -> Expr
pattern Elem' :: Type -> Expr -> Expr -> Expr
pattern Sum' :: Expr -> Expr
pattern Product' :: Expr -> Expr
pattern ModSum' :: Expr -> Expr -> Expr
pattern ModProduct' :: Expr -> Expr -> Expr
pattern Min1' :: Type -> Expr -> Expr
pattern Max1' :: Type -> Expr -> Expr
pattern ArgMin' :: Type -> Expr -> Expr
pattern ArgMax' :: Type -> Expr -> Expr
pattern All' :: Expr -> Expr
pattern Any' :: Expr -> Expr
pattern Sorted' :: Type -> Expr -> Expr
pattern Reversed' :: Type -> Expr -> Expr
pattern Range1' :: Expr -> Expr
pattern Range2' :: Expr -> Expr -> Expr
pattern Range3' :: Expr -> Expr -> Expr -> Expr
pattern Tuple' :: [Type] -> Expr
pattern Proj' :: [Type] -> Integer -> Expr -> Expr
pattern LessThan' :: Type -> Expr -> Expr -> Expr
pattern LessEqual' :: Type -> Expr -> Expr -> Expr
pattern GreaterThan' :: Type -> Expr -> Expr -> Expr
pattern GreaterEqual' :: Type -> Expr -> Expr -> Expr
pattern Equal' :: Type -> Expr -> Expr -> Expr
pattern NotEqual' :: Type -> Expr -> Expr -> Expr
pattern Fact' :: Expr -> Expr
pattern Choose' :: Expr -> Expr -> Expr
pattern Permute' :: Expr -> Expr -> Expr
pattern MultiChoose' :: Expr -> Expr -> Expr
pattern ConvexHullTrickInit' :: Expr
pattern ConvexHullTrickGetMin' :: Expr -> Expr -> Expr
pattern ConvexHullTrickInsert' :: Expr -> Expr -> Expr -> Expr
pattern SegmentTreeInitList' :: Semigroup' -> Expr -> Expr
pattern SegmentTreeGetRange' :: Semigroup' -> Expr -> Expr -> Expr -> Expr
pattern SegmentTreeSetPoint' :: Semigroup' -> Expr -> Expr -> Expr -> Expr
pattern Bottom' :: Type -> String -> Expr


module Jikka.Core.Convert.Alpha
rename :: MonadAlpha m => VarName -> m VarName
runExpr :: (MonadAlpha m, MonadError Error m) => [(VarName, VarName)] -> Expr -> m Expr
runToplevelExpr :: (MonadAlpha m, MonadError Error m) => [(VarName, VarName)] -> ToplevelExpr -> m ToplevelExpr
runProgram :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | <a>run</a> renames variables in exprs to avoid name conflictions, even
--   if the scopes of two variables are distinct.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   let x = 0
--   in y = x + x
--   in x = x + y
--   x + y
--   </pre>
--   
--   After:
--   
--   <pre>
--   let x0 = 0
--   in y1 = x0 + x0
--   in x2 = x0 + y1
--   x2 + y1
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.Core.Language.FreeVars

-- | <a>isFreeVar</a> checks if the given variable occurs in the tiven
--   expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam (VarName "y") IntTy (Var (VarName "x"))
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVar` Lam (VarName "x") IntTy (Var (VarName "x"))
--   False
--   </pre>
isFreeVar :: VarName -> Expr -> Bool

-- | <a>isUnusedVar</a> is the negation of <a>isFreeVar</a>.
--   
--   TODO: rename to <tt>isNonFreeVar</tt>?
isUnusedVar :: VarName -> Expr -> Bool

-- | <a>isFreeVarOrScopedVar</a> checks if the given variable occurs in the
--   tiven expr. This ignores contexts.
--   
--   <pre>
--   &gt;&gt;&gt; VarName "x" `isFreeVarOrScopedVar` Lam (VarName "x") IntTy (Var (VarName "y"))
--   True
--   </pre>
isFreeVarOrScopedVar :: VarName -> Expr -> Bool
freeTyVars :: Type -> [TypeName]
findUnusedVarName :: VarName -> Expr -> VarName
findUnusedVarName' :: Expr -> VarName

module Jikka.Core.Language.ArithmeticalExpr
data ArithmeticalExpr

-- | <a>parseArithmeticalExpr</a> converts a given expr to a normal form
--   &lt;math&gt;. This assumes given exprs have the type &lt;math&gt;.
parseArithmeticalExpr :: Expr -> ArithmeticalExpr
formatArithmeticalExpr :: ArithmeticalExpr -> Expr
integerArithmeticalExpr :: Integer -> ArithmeticalExpr
negateArithmeticalExpr :: ArithmeticalExpr -> ArithmeticalExpr
plusArithmeticalExpr :: ArithmeticalExpr -> ArithmeticalExpr -> ArithmeticalExpr
minusArithmeticalExpr :: ArithmeticalExpr -> ArithmeticalExpr -> ArithmeticalExpr
multArithmeticalExpr :: ArithmeticalExpr -> ArithmeticalExpr -> ArithmeticalExpr
isZeroArithmeticalExpr :: ArithmeticalExpr -> Bool
isOneArithmeticalExpr :: ArithmeticalExpr -> Bool

-- | <a>unNPlusKPattern</a> recognizes a pattern of &lt;math&gt; for a
--   variable &lt;math&gt; and an integer constant &lt;math&gt;.
unNPlusKPattern :: ArithmeticalExpr -> Maybe (VarName, Integer)

-- | <a>makeVectorFromArithmeticalExpr</a> makes a vector &lt;math&gt; and
--   a expr &lt;math&gt; from a given vector of variables &lt;math&gt; and
--   a given expr &lt;math&gt; s.t. &lt;math&gt; and &lt;math&gt; don't
--   have &lt;math&gt; as free variables and &lt;math&gt; holds. This
--   assumes given variables and exprs have the type &lt;math&gt;.
--   
--   <ul>
--   <li>The returned exprs are normalized with
--   <a>normalizeArithmeticalExpr</a>.</li>
--   </ul>
makeVectorFromArithmeticalExpr :: Vector VarName -> ArithmeticalExpr -> Maybe (Vector ArithmeticalExpr, ArithmeticalExpr)

-- | <a>makeAffineFunctionFromArithmeticalExpr</a> is a specialized version
--   of <a>makeVectorFromArithmeticalExpr</a>. This function returns
--   &lt;math&gt; for a given variable &lt;math&gt; and a given expr
--   &lt;math&gt; where &lt;math&gt; which doesn't use &lt;math&gt; free.
makeAffineFunctionFromArithmeticalExpr :: VarName -> ArithmeticalExpr -> Maybe (ArithmeticalExpr, ArithmeticalExpr)

-- | <a>splitConstantFactorArithmeticalExpr</a> finds &lt;math&gt; and
--   &lt;math&gt; for given &lt;math&gt; s.t. &lt;math&gt;.
splitConstantFactorArithmeticalExpr :: ArithmeticalExpr -> (Integer, ArithmeticalExpr)
instance GHC.Read.Read Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Show.Show Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Classes.Ord Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Classes.Eq Jikka.Core.Language.ArithmeticalExpr.ProductExpr
instance GHC.Read.Read Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Show.Show Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Classes.Ord Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Classes.Eq Jikka.Core.Language.ArithmeticalExpr.SumExpr
instance GHC.Show.Show Jikka.Core.Language.ArithmeticalExpr.ArithmeticalExpr
instance GHC.Classes.Eq Jikka.Core.Language.ArithmeticalExpr.ArithmeticalExpr
instance GHC.Classes.Ord Jikka.Core.Language.ArithmeticalExpr.ArithmeticalExpr

module Jikka.Core.Language.LambdaPatterns
pattern LamId :: Type -> Expr
pattern LamConst :: Type -> Expr -> Expr

module Jikka.Core.Language.Runtime
floorDiv :: MonadError Error m => Integer -> Integer -> m Integer
floorMod :: MonadError Error m => Integer -> Integer -> m Integer
ceilDiv :: MonadError Error m => Integer -> Integer -> m Integer
ceilMod :: MonadError Error m => Integer -> Integer -> m Integer
modinv :: MonadError Error m => Integer -> Integer -> m Integer
modpow :: MonadError Error m => Integer -> Integer -> Integer -> m Integer
fact :: MonadError Error m => Integer -> m Integer
choose :: MonadError Error m => Integer -> Integer -> m Integer
permute :: MonadError Error m => Integer -> Integer -> m Integer
multichoose :: MonadError Error m => Integer -> Integer -> m Integer

module Jikka.Core.Language.Util
genType :: MonadAlpha m => m Type
genVarName :: MonadAlpha m => VarName -> m VarName
genVarName' :: MonadAlpha m => m VarName
mapSubTypesM :: Monad m => (Type -> m Type) -> Type -> m Type
mapTypeLiteralM :: Monad m => (Type -> m Type) -> Literal -> m Literal
mapTypeExprM :: Monad m => (Type -> m Type) -> Expr -> m Expr
mapTypeExpr :: (Type -> Type) -> Expr -> Expr
mapTypeToplevelExprM :: Monad m => (Type -> m Type) -> ToplevelExpr -> m ToplevelExpr
mapTypeProgramM :: Monad m => (Type -> m Type) -> Program -> m Program
mapTypeProgram :: (Type -> Type) -> Program -> Program

-- | <a>mapExprM</a>` substitutes exprs using given two functions, which
--   are called in pre-order and post-order.
mapExprM' :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> Expr -> m Expr
mapExprToplevelExprM' :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> ToplevelExpr -> m ToplevelExpr
mapExprProgramM' :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> ([(VarName, Type)] -> Expr -> m Expr) -> Program -> m Program

-- | <a>mapExprM</a> is a wrapper of <a>mapExprM</a>`. This function works
--   in post-order.
mapExprM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> Expr -> m Expr
mapExprToplevelExprM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> [(VarName, Type)] -> ToplevelExpr -> m ToplevelExpr
mapExprProgramM :: Monad m => ([(VarName, Type)] -> Expr -> m Expr) -> Program -> m Program
mapExpr :: ([(VarName, Type)] -> Expr -> Expr) -> [(VarName, Type)] -> Expr -> Expr
mapExprToplevelExpr :: ([(VarName, Type)] -> Expr -> Expr) -> [(VarName, Type)] -> ToplevelExpr -> ToplevelExpr
mapExprProgram :: ([(VarName, Type)] -> Expr -> Expr) -> Program -> Program
listSubExprs :: Expr -> [Expr]
uncurryFunTy :: Type -> ([Type], Type)
uncurryLam :: Expr -> ([(VarName, Type)], Expr)
curryApp :: Expr -> (Expr, [Expr])
curryFunTy :: [Type] -> Type -> Type
curryLam :: [(VarName, Type)] -> Expr -> Expr
uncurryApp :: Expr -> [Expr] -> Expr
isVectorTy :: Type -> Bool
isVectorTy' :: [Type] -> Bool
sizeOfVectorTy :: Type -> Maybe Int
isMatrixTy :: Type -> Bool
isMatrixTy' :: [Type] -> Bool
sizeOfMatrixTy :: Type -> Maybe (Int, Int)
isConstantTimeBuiltin :: Builtin -> Bool

-- | <a>isConstantTimeExpr</a> checks whether given exprs are suitable to
--   propagate.
isConstantTimeExpr :: Expr -> Bool

-- | <a>replaceLenF</a> replaces <tt>len(f)</tt> in an expr with <tt>i +
--   k</tt>. * This assumes that there are no name conflicts.
replaceLenF :: MonadError Error m => VarName -> VarName -> Integer -> Expr -> m Expr

-- | <a>getRecurrenceFormulaBase</a> makes a pair <tt>((a_0, ..., a_{k -
--   1}), a)</tt> from <tt>setat (... (setat a 0 a_0) ...) (k - 1) a_{k -
--   1})</tt>.
getRecurrenceFormulaBase :: Expr -> ([Expr], Expr)
hoistMaybe :: Applicative m => Maybe a -> MaybeT m a


module Jikka.Core.Language.Beta

-- | <a>substitute</a> replaces the occrences of the given variable with
--   the given expr. This considers contexts.
--   
--   <pre>
--   &gt;&gt;&gt; flip evalAlphaT 0 $ substitute (VarName "x") (Lit (LitInt 0)) (Lam (VarName "y") IntTy (Var (VarName "x")))
--   Lam (VarName "y") IntTy (Lit (LitInt 0))
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; flip evalAlphaT 0 $ substitute (VarName "x") (Lit (LitInt 0)) (Lam (VarName "x") IntTy (Var (VarName "x")))
--   Lam (VarName "x") IntTy (Var (VarName "x"))
--   </pre>
substitute :: MonadAlpha m => VarName -> Expr -> Expr -> m Expr
substituteToplevelExpr :: (MonadAlpha m, MonadError Error m) => VarName -> Expr -> ToplevelExpr -> m ToplevelExpr


module Jikka.Core.Format
run :: Applicative m => Program -> m Text
formatBuiltinIsolated :: Builtin -> [Type] -> String
formatBuiltin :: Builtin -> [Type] -> [Expr] -> String
formatType :: Type -> String
formatExpr :: Expr -> String
formatProgram :: Program -> String
instance GHC.Read.Read Jikka.Core.Format.Prec
instance GHC.Show.Show Jikka.Core.Format.Prec
instance GHC.Classes.Ord Jikka.Core.Format.Prec
instance GHC.Classes.Eq Jikka.Core.Format.Prec
instance GHC.Read.Read Jikka.Core.Format.Assoc
instance GHC.Show.Show Jikka.Core.Format.Assoc
instance GHC.Enum.Enum Jikka.Core.Format.Assoc
instance GHC.Classes.Ord Jikka.Core.Format.Assoc
instance GHC.Classes.Eq Jikka.Core.Format.Assoc
instance GHC.Read.Read Jikka.Core.Format.Builtin'
instance GHC.Show.Show Jikka.Core.Format.Builtin'
instance GHC.Classes.Ord Jikka.Core.Format.Builtin'
instance GHC.Classes.Eq Jikka.Core.Format.Builtin'
instance GHC.Enum.Enum Jikka.Core.Format.Prec


module Jikka.Core.Language.TypeCheck
builtinToType :: MonadError Error m => Builtin -> [Type] -> m Type
semigroupToType :: Semigroup' -> Type
literalToType :: MonadError Error m => Literal -> m Type
arityOfBuiltin :: MonadError Error m => Builtin -> [Type] -> m Int
type TypeEnv = [(VarName, Type)]

-- | <a>typecheckExpr</a> checks that the given <a>Expr</a> has the correct
--   types.
typecheckExpr :: MonadError Error m => TypeEnv -> Expr -> m Type
typecheckToplevelExpr :: MonadError Error m => TypeEnv -> ToplevelExpr -> m Type
typecheckProgram :: MonadError Error m => Program -> m Type


-- | <a>Lint</a> module checks the invariants of data types. Mainly, this
--   checks types of <a>Expr</a>.
module Jikka.Core.Language.Lint
precondition :: MonadError Error m => m a -> m a
postcondition :: MonadError Error m => m a -> m a

-- | TODO: implement this
ensureEagerlyEvaluatable :: MonadError Error m => Program -> m ()
ensureWellTyped :: MonadError Error m => Program -> m ()


module Jikka.Core.Convert.TrivialLetElimination

-- | <a>run</a> remove let-exprs whose assigned variables are used only at
--   most once. This assumes that the program is alpha-converted.
--   
--   For example, this converts the following:
--   
--   <pre>
--   let f = fun y -&gt; y
--   in let x = 1
--   in f(x + x)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let x = 1
--   in (fun y -&gt; y) (x + x)
--   </pre>
--   
--   NOTE: this doesn't constant folding.
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program


module Jikka.Core.Language.RewriteRules
newtype RewriteRule m
RewriteRule :: ([(VarName, Type)] -> Expr -> m (Maybe Expr)) -> RewriteRule m
pureRewriteRule :: Monad m => ([(VarName, Type)] -> Expr -> Maybe Expr) -> RewriteRule m
simpleRewriteRule :: Monad m => (Expr -> Maybe Expr) -> RewriteRule m

-- | <a>applyRewriteRule</a> applies a given rule to a given expr. This
--   rewrites on all sub-exprs of the given expr, and repeats to rewrite
--   while it is possible.
--   
--   <ul>
--   <li>This function is idempotent.</li>
--   <li>This function doesn't terminate when a given rewrite rule doesn't
--   terminate.</li>
--   </ul>
applyRewriteRule :: MonadError Error m => RewriteRule m -> [(VarName, Type)] -> Expr -> StateT Integer m (Maybe Expr)
applyRewriteRule' :: MonadError Error m => RewriteRule m -> [(VarName, Type)] -> Expr -> m (Maybe Expr)
applyRewriteRuleToplevelExpr :: MonadError Error m => RewriteRule m -> [(VarName, Type)] -> ToplevelExpr -> StateT Integer m (Maybe ToplevelExpr)
applyRewriteRuleProgram :: MonadError Error m => RewriteRule m -> Program -> m (Maybe Program)
applyRewriteRuleProgram' :: MonadError Error m => RewriteRule m -> Program -> m Program
traceRewriteRule :: Monad m => RewriteRule m -> RewriteRule m
instance GHC.Base.Monad m => GHC.Base.Semigroup (Jikka.Core.Language.RewriteRules.RewriteRule m)
instance GHC.Base.Monad m => GHC.Base.Monoid (Jikka.Core.Language.RewriteRules.RewriteRule m)


module Jikka.Core.Convert.StrengthReduction

-- | TODO: Split and remove this module.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


-- | &lt;math&gt;
module Jikka.Core.Convert.SpecializeFoldl

-- | <a>run</a> reduces summations and products.
--   
--   <h2>Example</h2>
--   
--   Before:
--   
--   <pre>
--   foldl (fun x y -&gt; x + y) 0 xs
--   </pre>
--   
--   After:
--   
--   <pre>
--   sum xs
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   <h3>Source functions</h3>
--   
--   <ul>
--   <li><a>Foldl</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Destination functions</h3>
--   
--   <ul>
--   <li><a>Sum</a> &lt;math&gt;</li>
--   <li><a>Product</a> &lt;math&gt;</li>
--   <li><a>ModSum</a> &lt;math&gt;</li>
--   <li><a>ModProduct</a> &lt;math&gt;</li>
--   <li><a>All</a> &lt;math&gt;</li>
--   <li><a>Any</a> &lt;math&gt;</li>
--   <li><a>Max1</a> &lt;math&gt;</li>
--   <li><a>Min1</a> &lt;math&gt;</li>
--   <li><a>Iterate</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


-- | &lt;math&gt;
module Jikka.Core.Convert.EqualitySolving
run :: MonadError Error m => Program -> m Program
rule :: Monad m => RewriteRule m


-- | &lt;math&gt;
module Jikka.Core.Convert.ConstantFolding

-- | <a>run</a> folds constants in given programs. For example, this
--   converts the following:
--   
--   <pre>
--   3 x + 2 + 1
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   3 x + 3
--   </pre>
run :: MonadError Error m => Program -> m Program
rule :: MonadError Error m => RewriteRule m

-- | <h2>List of functions which are reduced</h2>
--   
--   <h3>Basic arithmetical functions</h3>
--   
--   <ul>
--   <li><a>Negate</a> &lt;math&gt;</li>
--   <li><a>Plus</a> &lt;math&gt;</li>
--   <li><a>Minus</a> &lt;math&gt;</li>
--   <li><a>Mult</a> &lt;math&gt;</li>
--   <li><a>FloorDiv</a> &lt;math&gt;</li>
--   <li><a>FloorMod</a> &lt;math&gt;</li>
--   <li><a>CeilDiv</a> &lt;math&gt;</li>
--   <li><a>CeilMod</a> &lt;math&gt;</li>
--   <li><a>Pow</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Advanced arithmetical functions</h3>
--   
--   <ul>
--   <li><a>Abs</a> &lt;math&gt;</li>
--   <li><a>Gcd</a> &lt;math&gt;</li>
--   <li><a>Lcm</a> &lt;math&gt;</li>
--   </ul>
reduceConstArithmeticalExpr :: Monad m => RewriteRule m

-- | <h2>List of functions which are reduced</h2>
--   
--   <h3>Max functions</h3>
--   
--   <ul>
--   <li><a>Min2</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   <li><a>Max2</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   </ul>
reduceConstMaxExpr :: Monad m => RewriteRule m

-- | <h2>List of functions which are reduced</h2>
--   
--   <h3>Boolean functions</h3>
--   
--   <ul>
--   <li><a>Not</a> &lt;math&gt;</li>
--   <li><a>And</a> &lt;math&gt;</li>
--   <li><a>Or</a> &lt;math&gt;</li>
--   <li><a>Implies</a> &lt;math&gt;</li>
--   <li><a>If</a> &lt;math&gt;</li>
--   </ul>
reduceConstBooleanExpr :: Monad m => RewriteRule m

-- | <h2>List of functions which are reduced</h2>
--   
--   <h3>Bitwise boolean functions</h3>
--   
--   <ul>
--   <li><a>BitNot</a> &lt;math&gt;</li>
--   <li><a>BitAnd</a> &lt;math&gt;</li>
--   <li><a>BitOr</a> &lt;math&gt;</li>
--   <li><a>BitXor</a> &lt;math&gt;</li>
--   <li><a>BitLeftShift</a> &lt;math&gt;</li>
--   <li><a>BitRightShift</a> &lt;math&gt;</li>
--   </ul>
reduceConstBitExpr :: Monad m => RewriteRule m

-- | <h2>List of functions which are reduced</h2>
--   
--   <h3>Comparison functions</h3>
--   
--   <ul>
--   <li><a>LessThan</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   <li><a>LessEqual</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   <li><a>GreaterThan</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   <li><a>GreaterEqual</a> &lt;math&gt; (specialized to
--   &lt;math&gt;)</li>
--   <li><a>Equal</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   <li><a>NotEqual</a> &lt;math&gt; (specialized to &lt;math&gt;)</li>
--   </ul>
reduceConstComparison :: Monad m => RewriteRule m


module Jikka.Core.Convert.CloseMin

-- | <a>run</a> reduces maximums and minimums.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   max (map (fun x -&gt; 3 + f x) xs)
--   </pre>
--   
--   After:
--   
--   <pre>
--   3 + max (map f xs)
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   &lt;math&gt;
--   
--   <h3>Target functions</h3>
--   
--   <ul>
--   <li><a>Max1</a> &lt;math&gt;</li>
--   <li><a>Min1</a> &lt;math&gt;</li>
--   <li><a>ArgMax</a> &lt;math&gt;</li>
--   <li><a>ArgMin</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Related functions</h3>
--   
--   <ul>
--   <li><a>Max2</a> &lt;math&gt;</li>
--   <li><a>Min2</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Build functions</h3>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   <li><a>Range1</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Map functions</h3>
--   
--   <ul>
--   <li><a>Map</a> &lt;math&gt;</li>
--   <li><a>Filter</a> &lt;math&gt;</li>
--   <li><a>Reversed</a> &lt;math&gt;</li>
--   <li><a>Sorted</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: Monad m => RewriteRule m
reduceMin :: Monad m => RewriteRule m
reduceMax :: Monad m => RewriteRule m

-- | TODO: implement this
reduceArgMin :: Monad m => RewriteRule m

-- | TODO: implement this
reduceArgMax :: Monad m => RewriteRule m


module Jikka.Core.Convert.BubbleLet

-- | <a>run</a> moves let-exprs in lambdas passed to higher-order functions
--   to the outer of the higher-order functions.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   map (fun x -&gt; let c = 12345 in c * x) xs
--   </pre>
--   
--   After:
--   
--   <pre>
--   let c = 12345 in map (fun x -&gt; c * x) xs
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m


module Jikka.Core.Convert.Beta

-- | <a>run</a> does beta-reduction.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   (fun x -&gt; x + x) y
--   </pre>
--   
--   After:
--   
--   <pre>
--   y + y
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m


module Jikka.Core.Convert.UnpackTuple

-- | <a>run</a> removes unnecessary introductions and eliminations of
--   tuples. For example, this converts the following:
--   
--   <pre>
--   (fun xs -&gt; (proj0 xs) + (proj1 xs)) (tuple 2 1)
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   (fun x0 x1 -&gt; x0 + x1) 2 1
--   </pre>
--   
--   This can remove 1-tuples over higher-order functions. For example,
--   this converts the following:
--   
--   <pre>
--   foldl (fun xs y -&gt; tuple (proj0 xs + y) (tuple 0) [1, 2, 3]
--   </pre>
--   
--   to the follwoing:
--   
--   <pre>
--   tuple (foldl (fun x y -&gt; x + y) 0 [1, 2, 3])
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: (MonadAlpha m, MonadError Error m) => RewriteRule m


module Jikka.Core.Convert.TypeInfer

-- | <a>run</a> does type inference.
--   
--   <ul>
--   <li>This assumes that program has no name conflicts.</li>
--   </ul>
--   
--   Before:
--   
--   <pre>
--   let f = fun y -&gt; y
--   in let x = 1
--   in f(x + x)
--   </pre>
--   
--   After:
--   
--   <pre>
--   let f: int -&gt; int = fun y: int -&gt; y
--   in let x: int = 1
--   in f(x + x)
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
runExpr :: (MonadAlpha m, MonadError Error m) => [(VarName, Type)] -> Expr -> m Expr
runRule :: (MonadAlpha m, MonadError Error m) => [(VarName, Type)] -> Expr -> Expr -> m ([(VarName, Type)], Expr, Expr)
data Equation
TypeEquation :: Type -> Type -> Equation
TypeAssertion :: VarName -> Type -> Equation
formularizeProgram :: (MonadAlpha m, MonadError Error m) => Program -> m [Equation]
sortEquations :: [Equation] -> ([(Type, Type)], [(VarName, Type)])
mergeAssertions :: [(VarName, Type)] -> [(Type, Type)]

-- | <a>Subst</a> is type substituion. It's a mapping from type variables
--   to their actual types.
newtype Subst
Subst :: Map TypeName Type -> Subst
[unSubst] :: Subst -> Map TypeName Type
subst :: Subst -> Type -> Type
solveEquations :: MonadError Error m => [(Type, Type)] -> m Subst
substProgram :: Subst -> Program -> Program
instance GHC.Read.Read Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Show.Show Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Classes.Ord Jikka.Core.Convert.TypeInfer.Equation
instance GHC.Classes.Eq Jikka.Core.Convert.TypeInfer.Equation


-- | &lt;math&gt;
module Jikka.Core.Convert.SegmentTree
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: (MonadAlpha m, MonadError Error m) => RewriteRule m

-- | <a>reduceCumulativeSum</a> converts combinations of cumulative sums
--   and array assignments to segment trees.
reduceCumulativeSum :: (MonadAlpha m, MonadError Error m) => RewriteRule m

-- | <tt>reduceFromMin</tt> uses segment trees from accumulation of min/max
--   which are not reducible to cumulative sums.
--   
--   TODO: implement this
reduceMin :: MonadAlpha m => RewriteRule m


-- | <a>RemoveUnusedVars</a> remove unused variables from exprs.
module Jikka.Core.Convert.RemoveUnusedVars

-- | <a>run</a> removes unused variables in given programs.
--   
--   This also removes variables for recursion, i.e. "rec" flags.
--   <a>ToplevelLetRec</a> may becomes <a>ToplevelLet</a>.
--   
--   For example, this converts
--   
--   <pre>
--   let rec solve x =
--       let y = 0
--       in x
--   in solve
--   </pre>
--   
--   to
--   
--   <pre>
--   let solve x =
--       x
--   in solve
--   </pre>
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program


module Jikka.Core.Convert.PropagateMod

-- | <a>run</a> propagates <a>FloorMod</a> to leaves of exprs. For example,
--   this converts the following:
--   
--   <pre>
--   mod ((fun x -&gt; x * x + x) y) 1000000007
--   </pre>
--   
--   to:
--   
--   <pre>
--   (fun x -&gt; mod (mod (x * x) 1000000007 + x) 1000000007) y
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.Core.Convert.MatrixExponentiation

-- | <a>run</a> simplifies an affine functions from vectors to vectors in
--   <tt>iterate</tt> (<a>Iterate</a>) functions.
--   
--   <h2>Examples</h2>
--   
--   This makes matrix multiplication. Before:
--   
--   <pre>
--   iterate n (fun xs -&gt; (xs[0] + 2 * xs[1], xs[1])) xs
--   </pre>
--   
--   After:
--   
--   <pre>
--   matap (matpow ((1, 2), (0, 1)) n) xs
--   </pre>
--   
--   Also this works on integers. Before:
--   
--   <pre>
--   iterate n (fun x -&gt; (2 x + 1)) x
--   </pre>
--   
--   After:
--   
--   <pre>
--   (2 ** n) * x + (2 ** n - 1) / (n - 1)
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


-- | &lt;math&gt;
module Jikka.Core.Convert.MakeScanl

-- | <a>run</a> replaces <a>Foldl</a> with <a>Scanl</a>.
--   
--   <h2>Example</h2>
--   
--   Before:
--   
--   <pre>
--   let xs = range n
--   xs[0] &lt;- 0
--   xs[1] &lt;- 1
--   foldl (fun a i -&gt; do
--      xs[i + 2] &lt;- xs[i] + xs[i + 1]
--      xs
--   ) xs (range (n - 2))
--   </pre>
--   
--   After:
--   
--   <pre>
--   0 : map snd (
--      scanl (fun a i -&gt; (snd a, fst a + snd a))
--            (0, 1)
--            (range (n - 2)))
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   <h3>Build functions</h3>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   <li><a>Range1</a> &lt;math&gt;</li>
--   <li><a>Build</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Map functions</h3>
--   
--   <ul>
--   <li><a>Scanl</a> &lt;math&gt;</li>
--   <li><a>SetAt</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Fold functions</h3>
--   
--   <ul>
--   <li><a>Foldl</a> &lt;math&gt;</li>
--   <li><a>At</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m

-- | <h2>List of builtin functions which are reduced</h2>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   <li><a>Scanl</a> &lt;math&gt;</li>
--   </ul>
reduceScanlBuild :: Monad m => RewriteRule m

-- | <ul>
--   <li>This assumes that <a>Range2</a> and <a>Range3</a> are already
--   converted to <a>Range1</a> (<a>ShortCutFusion</a>).</li>
--   <li>This assumes that combinations <a>Foldl</a> and <a>Map</a>
--   squashed (<a>ShortCutFusion</a>).</li>
--   <li>This assumes that constants are already folded
--   (<a>ConstantFolding</a>).</li>
--   </ul>
reduceFoldlSetAtRecurrence :: MonadAlpha m => RewriteRule m

-- | <ul>
--   <li>This assumes that <a>Range2</a> and <a>Range3</a> are already
--   converted to <a>Range1</a> (<a>ShortCutFusion</a>).</li>
--   <li>This assumes that combinations <a>Foldl</a> and <a>Map</a>
--   squashed (<a>ShortCutFusion</a>).</li>
--   <li>This assumes that constants are already folded
--   (<a>ConstantFolding</a>).</li>
--   </ul>
reduceFoldlSetAtAccumulation :: MonadAlpha m => RewriteRule m
reduceFoldlSetAtGeneric :: MonadAlpha m => RewriteRule m

-- | <a>getRecurrenceFormulaBase</a> makes a pair <tt>((a_0, ..., a_{k -
--   1}), a)</tt> from <tt>setat (... (setat a 0 a_0) ...) (k - 1) a_{k -
--   1})</tt>.
getRecurrenceFormulaBase :: Expr -> ([Expr], Expr)

-- | <a>getRecurrenceFormulaStep1</a> removes <a>At</a> in <tt>body</tt>.
getRecurrenceFormulaStep1 :: MonadAlpha m => Integer -> Type -> VarName -> VarName -> Expr -> m (Maybe Expr)

-- | <a>getRecurrenceFormulaStep</a> replaces <a>At</a> in <tt>body</tt>
--   with <a>Proj</a>.
getRecurrenceFormulaStep :: MonadAlpha m => Integer -> Integer -> Type -> VarName -> VarName -> Expr -> m (Maybe Expr)


module Jikka.Core.Convert.KubaruToMorau

-- | <a>run</a> converts Kubaru DP (for each &lt;math&gt;, updates (
--   mathrm{dp}(j) gets f(mathrm{dp}(j), mathrm{dp}(i)) ) for each
--   &lt;math&gt;) to Morau DP (for each &lt;math&gt;, computes (
--   mathrm{dp}(i) = F(lbrace mathrm{dp}(j) mid j lt i rbrace) )).
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   foldl (fun dp i -&gt;
--       foldl (fun dp j -&gt;
--           setAt dp j (
--               f dp[j] dp[i])
--           ) dp (range (i + 1) n)
--       ) dp (range n)
--   </pre>
--   
--   After:
--   
--   <pre>
--   build (fun dp' -&gt;
--       foldl (fun dp_i j -&gt;
--           f dp_i dp'[j]
--           ) dp[i] (range i)
--       ) [] n
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | TODO: remove the assumption that the length of <tt>a</tt> is equals to
--   <tt>n</tt>
rule :: (MonadAlpha m, MonadError Error m) => RewriteRule m

-- | <tt>runFunctionBody c i j step y x k</tt> returns <tt>step'(y, x, i,
--   k)</tt> s.t. <tt>step(c, i, j) = step'(c[i + j + 1], c[i], i, i + j +
--   1)</tt>
runFunctionBody :: (MonadAlpha m, MonadError Error m) => VarName -> VarName -> VarName -> Expr -> VarName -> VarName -> VarName -> MaybeT m Expr


module Jikka.Core.Convert.Eta
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m


module Jikka.Core.Convert.CumulativeSum

-- | <a>run</a> introduces cumulative sums.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   sum (fun i -&gt; a[i]) (range n)
--   </pre>
--   
--   After:
--   
--   <pre>
--   let b = scanl (+) 0 a in b[n]
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m


-- | &lt;math&gt;
module Jikka.Core.Convert.ConvexHullTrick

-- | <a>run</a> optimizes a DP which has the recurrence relation
--   &lt;math&gt; where only appropriate elements of &lt;math&gt; are used
--   in &lt;math&gt;.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: (MonadAlpha m, MonadError Error m) => RewriteRule m
parseLinearFunctionBody :: MonadAlpha m => VarName -> VarName -> Integer -> Expr -> m (Maybe (Expr, Expr, Expr, Expr, Expr, Maybe Expr))

-- | <a>parseLinearFunctionBody</a>` parses the body of a linear function
--   which can be decomposed to convex hull trick.
--   <tt>parseLinearFunctionBody' f i j e</tt> finds a 4-tuple <tt>a, b, c,
--   d</tt> where <tt>e = a(f[j], j) c(f[&lt; i], i) + b(f[j], j) +
--   d(f[&lt; i], i)</tt>.
--   
--   TODO: What is the relation between <tt>j</tt> and <tt>k</tt>?
parseLinearFunctionBody' :: VarName -> VarName -> VarName -> Expr -> Maybe (Expr, Expr, Expr, Expr)


module Jikka.Core.Convert.ConstantPropagation

-- | <a>run</a> does constant propagation. This assumes that the program is
--   alpha-converted.
--   
--   For example, this converts the following:
--   
--   <pre>
--   let x = 1
--   in let f = fun y -&gt; y
--   in x + x + f(x)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let f = fun y -&gt; y
--   in 1 + 1 + f(1)
--   </pre>
--   
--   NOTE: this doesn't constant folding.
run :: MonadError Error m => Program -> m Program
run' :: Program -> Program


-- | &lt;math&gt;
module Jikka.Core.Convert.CloseSum

-- | <a>run</a> reduces summations and products.
--   
--   <ul>
--   <li>This doen't do nothing about <a>Foldl</a>.</li>
--   </ul>
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   foldl (fun y x -&gt; y + x) 0 (range n)
--   </pre>
--   
--   After:
--   
--   <pre>
--   x * (x - 1) / 2
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   <h3>Target functions</h3>
--   
--   <ul>
--   <li><a>Sum</a> &lt;math&gt;</li>
--   <li><a>Product</a> &lt;math&gt;</li>
--   <li><a>ModSum</a> &lt;math&gt;</li>
--   <li><a>ModProduct</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Arithmetical functions</h3>
--   
--   <ul>
--   <li><a>Negate</a> &lt;math&gt;</li>
--   <li><a>Plus</a> &lt;math&gt;</li>
--   <li><a>Minus</a> &lt;math&gt;</li>
--   <li><a>Mult</a> &lt;math&gt;</li>
--   <li><a>Pow</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Arithmetical functions with modulo</h3>
--   
--   <ul>
--   <li><a>ModNegate</a> &lt;math&gt;</li>
--   <li><a>ModPlus</a> &lt;math&gt;</li>
--   <li><a>ModMinus</a> &lt;math&gt;</li>
--   <li><a>ModMult</a> &lt;math&gt;</li>
--   <li><a>ModPow</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Build functions</h3>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   <li><a>Range1</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Map functions</h3>
--   
--   <ul>
--   <li><a>Map</a> &lt;math&gt;</li>
--   <li><a>Filter</a> &lt;math&gt;</li>
--   <li><a>Reversed</a> &lt;math&gt;</li>
--   <li><a>Sorted</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m
reduceSum :: MonadAlpha m => RewriteRule m

-- | TODO: implement this.
reduceProduct :: Monad m => RewriteRule m

-- | <ul>
--   <li>This assumes that <tt>ModFloor</tt> is already propagated.</li>
--   </ul>
reduceModSum :: MonadAlpha m => RewriteRule m

-- | TODO: implement this.
reduceModProduct :: Monad m => RewriteRule m


module Jikka.Core.Convert.CloseAll

-- | <a>run</a> reduces <a>All</a> and <a>Any</a>.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   any (filter (fun x -&gt; x || f x) xs)
--   </pre>
--   
--   After:
--   
--   <pre>
--   any xs || any (map f xs)
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   &lt;math&gt;
--   
--   <h3>Target functions</h3>
--   
--   <ul>
--   <li><a>All</a> &lt;math&gt;</li>
--   <li><a>Any</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Boolean functions</h3>
--   
--   <ul>
--   <li><a>Not</a> &lt;math&gt;</li>
--   <li><a>And</a> &lt;math&gt;</li>
--   <li><a>Or</a> &lt;math&gt;</li>
--   <li><a>Implies</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Build functions</h3>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>List Map functions</h3>
--   
--   <ul>
--   <li><a>Map</a> &lt;math&gt;</li>
--   <li><a>Filter</a> &lt;math&gt;</li>
--   <li><a>Reversed</a> &lt;math&gt;</li>
--   <li><a>Sorted</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m
reduceAll :: MonadAlpha m => RewriteRule m
reduceAny :: MonadAlpha m => RewriteRule m


module Jikka.Core.Convert.ArithmeticalExpr

-- | <a>run</a> sorts arithmetical exprs.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   1 + a * 1 + b - b
--   </pre>
--   
--   After:
--   
--   <pre>
--   a + 1
--   </pre>
run :: MonadError Error m => Program -> m Program


module Jikka.Core.Convert.ANormal

-- | <a>run</a> makes a given program A-normal form. A program is an
--   A-normal form iff assigned exprs of all let-statements are values or
--   function applications. For example, this converts the following:
--   
--   <pre>
--   (let x = 1 in x) + ((fun y -&gt; y) 1)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let x = 1
--   in let f = fun y -&gt; y
--   in let z = f x
--   in z
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


-- | <a>FromCore</a> converts exprs of our core language to exprs of C++.
module Jikka.CPlusPlus.Convert.FromCore
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.CPlusPlus.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> IOFormat -> m Program

module Jikka.Core.Language.Value
data Value
ValInt :: Integer -> Value
ValBool :: Bool -> Value
ValList :: Vector Value -> Value
ValTuple :: [Value] -> Value
ValBuiltin :: Builtin -> [Type] -> [Value] -> Value

-- | The <a>Env</a> may contain the <a>ValLambda</a> cyclicly.
ValLambda :: Maybe VarName -> Env -> VarName -> Type -> Expr -> Value
type Env = [(VarName, Value)]
literalToValue :: MonadError Error m => Literal -> m Value
valueToInt :: MonadError Error m => Value -> m Integer
valueToList :: MonadError Error m => Value -> m (Vector Value)
valueToIntList :: MonadError Error m => Value -> m [Integer]
valueToBool :: MonadError Error m => Value -> m Bool
valueToBoolList :: MonadError Error m => Value -> m [Bool]
valueToTuple :: MonadError Error m => Value -> m [Value]
valueToIntPair :: MonadError Error m => Value -> m (Integer, Integer)
valueToVector :: MonadError Error m => Value -> m (Vector Integer)
valueToMatrix :: MonadError Error m => Value -> m (Matrix Integer)
valueFromVector :: Vector Integer -> Value
valueFromMatrix :: Matrix Integer -> Value
valueToModVector :: MonadError Error m => Integer -> Value -> m (Vector ModInt)
valueToModMatrix :: MonadError Error m => Integer -> Value -> m (Matrix ModInt)
valueFromModVector :: Vector ModInt -> Value
valueFromModMatrix :: Matrix ModInt -> Value
compareValues :: Value -> Value -> Maybe Ordering
compareValues' :: Value -> Value -> Ordering
minValue :: Value -> Value -> Value
maxValue :: Value -> Value -> Value
formatValue :: Value -> String
readValueIO :: (MonadError Error m, MonadIO m) => IOFormat -> m ([Value], Map String Value)
writeValueIO :: (MonadError Error m, MonadIO m) => IOFormat -> Map String Value -> Value -> m ()
instance GHC.Read.Read Jikka.Core.Language.Value.Value
instance GHC.Classes.Eq Jikka.Core.Language.Value.Value


-- | <a>Evaluate</a> evaluates exprs to values. Also this recognizes users'
--   inputs at once.
--   
--   The implementation assumes that all variable names don't conflict even
--   when their scopes are distinct.
module Jikka.Core.Evaluate
run :: (MonadAlpha m, MonadFix m, MonadError Error m) => Program -> [Value] -> m Value

-- | <a>callProgram</a> evaluates programs with given arguments. This
--   function assumes that given programs are ready for eager evaluation
--   (<tt>ensureEagerlyEvaluatable</tt>).
callProgram :: (MonadFix m, MonadError Error m) => Program -> [Value] -> m Value
data Value
ValInt :: Integer -> Value
ValBool :: Bool -> Value
ValList :: Vector Value -> Value
ValTuple :: [Value] -> Value
ValBuiltin :: Builtin -> [Type] -> [Value] -> Value

-- | The <a>Env</a> may contain the <a>ValLambda</a> cyclicly.
ValLambda :: Maybe VarName -> Env -> VarName -> Type -> Expr -> Value


module Jikka.Core.Parse.Token
data Operator
Plus :: Operator
Minus :: Operator
Mult :: Operator
FloorDiv :: Operator
FloorMod :: Operator
CeilDiv :: Operator
CeilMod :: Operator
Pow :: Operator
Not :: Operator
And :: Operator
Or :: Operator
Implies :: Operator
BitNot :: Operator
BitAnd :: Operator
BitOr :: Operator
BitXor :: Operator
BitLShift :: Operator
BitRShift :: Operator
Min :: Operator
Max :: Operator
DoubleEqual :: Operator
NotEqual :: Operator
LessThan :: Operator
LessEqual :: Operator
GreaterThan :: Operator
GreaterEqual :: Operator

-- | We don't have to classify tokens in detail, but it's convenient for
--   testing and debugging.
data Token
Ident :: String -> Token
Int :: Integer -> Token
Bool :: Bool -> Token
String :: String -> Token
Let :: Token
Rec :: Token
In :: Token
If :: Token
Then :: Token
Else :: Token
Fun :: Token
Dot :: Token
Forall :: Token
Arrow :: Token
Equal :: Token
Colon :: Token
Comma :: Token
Underscore :: Token
BackArrow :: Token
At :: Token
OpenBracket :: Token
OpenParen :: Token
CloseBracket :: Token
CloseParen :: Token
Operator :: Operator -> Token
type Token' = WithLoc Token
instance GHC.Read.Read Jikka.Core.Parse.Token.Operator
instance GHC.Show.Show Jikka.Core.Parse.Token.Operator
instance GHC.Classes.Ord Jikka.Core.Parse.Token.Operator
instance GHC.Classes.Eq Jikka.Core.Parse.Token.Operator
instance GHC.Read.Read Jikka.Core.Parse.Token.Token
instance GHC.Show.Show Jikka.Core.Parse.Token.Token
instance GHC.Classes.Ord Jikka.Core.Parse.Token.Token
instance GHC.Classes.Eq Jikka.Core.Parse.Token.Token


-- | See also Haskell's <a>Syntax Reference</a>.
module Jikka.Core.Parse.Happy
runProgram :: (MonadAlpha m, MonadError Error m) => [WithLoc Token] -> m Program
runExpr :: (MonadAlpha m, MonadError Error m) => [WithLoc Token] -> m Expr
runType :: (MonadAlpha m, MonadError Error m) => [WithLoc Token] -> m Type
runRule :: (MonadAlpha m, MonadError Error m) => [WithLoc Token] -> m (String, [(VarName, Type)], Expr, Expr)


module Jikka.Core.Parse.Alex
run :: MonadError Error m => String -> m [Token']
instance GHC.Show.Show Jikka.Core.Parse.Alex.AlexPosn
instance GHC.Classes.Eq Jikka.Core.Parse.Alex.AlexPosn
instance GHC.Base.Functor Jikka.Core.Parse.Alex.Alex
instance GHC.Base.Applicative Jikka.Core.Parse.Alex.Alex
instance GHC.Base.Monad Jikka.Core.Parse.Alex.Alex

module Jikka.Core.Parse
run :: (MonadAlpha m, MonadError Error m) => FilePath -> Text -> m Program
parseProgram :: (MonadAlpha m, MonadError Error m) => String -> m Program
parseExpr :: (MonadAlpha m, MonadError Error m) => String -> m Expr
parseType :: (MonadAlpha m, MonadError Error m) => String -> m Type
parseRule :: (MonadAlpha m, MonadError Error m) => String -> m (String, [(VarName, Type)], Expr, Expr)

module Jikka.Core.Language.QuasiRules
liftError :: ExceptT Error Q a -> Q a
lookupValueName :: (MonadTrans t, Monad (t Q), MonadFail (t Q)) => String -> t Q Name
fromVarName :: VarName -> Q Name
fromTypeName :: TypeName -> Q Name
liftDataP :: Data a => a -> Q Pat
data Env
Env :: [(VarName, Maybe Exp)] -> [(TypeName, Name)] -> Env
[vars] :: Env -> [(VarName, Maybe Exp)]
[typeVars] :: Env -> [(TypeName, Name)]
toPatT :: Type -> StateT Env Q Pat
toPatL :: Literal -> StateT Env Q Pat
toPatE :: Expr -> StateT Env Q Pat
toExpT :: Type -> StateT Env Q Exp
toExpL :: Literal -> StateT Env Q Exp
toExpE :: Expr -> StateT Env Q ([Stmt], Exp)
ruleExp :: String -> Q Exp
r :: QuasiQuoter


-- | &lt;math&gt;
module Jikka.Core.Convert.ShortCutFusion

-- | <a>run</a> does short cut fusion.
--   
--   <ul>
--   <li>This function is mainly for polymorphic reductions. This dosn't do
--   much about concrete things, e.g., arithmetical operations.</li>
--   <li>This does nothing about <a>Build</a>, <a>Scanl</a> or <a>SetAt</a>
--   except combinations with <a>Len</a> or <a>At</a>.</li>
--   </ul>
--   
--   <h2>Example</h2>
--   
--   Before:
--   
--   <pre>
--   length (map f (cons (-1) (range n)))
--   </pre>
--   
--   After:
--   
--   <pre>
--   n + 1
--   </pre>
--   
--   <h2>List of builtin functions which are reduced</h2>
--   
--   <h3>Build functions</h3>
--   
--   <ul>
--   <li><tt>Nil</tt> &lt;math&gt;</li>
--   <li><a>Cons</a> &lt;math&gt;</li>
--   <li><a>Range1</a> &lt;math&gt;</li>
--   <li><a>Range2</a> &lt;math&gt;</li>
--   <li><a>Range3</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Map functions</h3>
--   
--   <ul>
--   <li><a>Map</a> &lt;math&gt;</li>
--   <li><a>Filter</a> &lt;math&gt;</li>
--   <li><a>Reversed</a> &lt;math&gt;</li>
--   <li><a>Sorted</a> &lt;math&gt;</li>
--   </ul>
--   
--   <h3>Fold functions</h3>
--   
--   <ul>
--   <li><a>Foldl</a> &lt;math&gt;</li>
--   <li><a>Len</a> &lt;math&gt;</li>
--   <li><a>At</a> &lt;math&gt;</li>
--   <li><a>Elem</a> &lt;math&gt;</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
rule :: MonadAlpha m => RewriteRule m

-- | <ul>
--   <li><a>Range1</a> remains.</li>
--   <li><a>Range2</a> is removed.</li>
--   <li><a>Range3</a> is removed.</li>
--   <li><tt>Nil</tt> and <a>Cons</a> are kept as is.</li>
--   </ul>
reduceBuild :: MonadAlpha m => RewriteRule m
reduceMapBuild :: MonadAlpha m => RewriteRule m
reduceMap :: Monad m => RewriteRule m

-- | <ul>
--   <li>Functions are reordered as:</li>
--   <li><tt>Sort</tt> and <a>Reversed</a> (functions to reorder) are
--   lastly applied to lists</li>
--   <li><a>Map</a> (functions to modify lists)</li>
--   <li><a>Filter</a> (funcitons to reduce lengths) is firstly applied to
--   lists</li>
--   </ul>
reduceMapMap :: MonadAlpha m => RewriteRule m
reduceFoldMap :: MonadAlpha m => RewriteRule m
reduceFold :: Monad m => RewriteRule m
reduceFoldBuild :: MonadAlpha m => RewriteRule m


-- | <a>Convert</a> is a module to combine other all optimizers.
module Jikka.Core.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.Main.Target
data Target
PythonTarget :: Target
RestrictedPythonTarget :: Target
CoreTarget :: Target
CPlusPlusTarget :: Target
parseTarget :: String -> Either Error Target
instance GHC.Read.Read Jikka.Main.Target.Target
instance GHC.Show.Show Jikka.Main.Target.Target
instance GHC.Classes.Ord Jikka.Main.Target.Target
instance GHC.Classes.Eq Jikka.Main.Target.Target


-- | <a>Expr</a> module has the basic data types for the standard Python.
--   See the Python's <tt>ast</tt> module
--   (<a>https://docs.python.org/ja/3/library/ast.html#abstract-grammar</a>)
--   for reference.
module Jikka.Python.Language.Expr
newtype Ident
Ident :: String -> Ident
unIdent :: Ident -> String
type Ident' = WithLoc Ident
data Constant
ConstNone :: Constant
ConstInt :: Integer -> Constant
ConstBool :: Bool -> Constant
ConstString :: String -> Constant
ConstBytes :: [Int8] -> Constant
ConstFloat :: Double -> Constant
ConstImaginary :: Double -> Constant
data Statement
FunctionDef :: Ident' -> Arguments -> [Statement'] -> [Decorator] -> Maybe Type' -> Statement
AsyncFunctionDef :: Ident' -> Arguments -> [Statement'] -> [Decorator] -> Maybe Type' -> Statement
ClassDef :: Ident' -> [Expr'] -> [Keyword'] -> [Statement'] -> [Decorator] -> Statement
Return :: Maybe Expr' -> Statement
Delete :: [Target'] -> Statement
Assign :: [Target'] -> Expr' -> Statement
AugAssign :: Target' -> Operator -> Expr' -> Statement
AnnAssign :: Target' -> Type' -> Maybe Expr' -> Statement

-- | <pre>
--   For target iter body orelse
--   </pre>
For :: Target' -> Expr' -> [Statement'] -> [Statement'] -> Statement
AsyncFor :: Target' -> Expr' -> [Statement'] -> [Statement'] -> Statement

-- | <pre>
--   While test body orelse
--   </pre>
While :: Expr' -> [Statement'] -> [Statement'] -> Statement
If :: Expr' -> [Statement'] -> [Statement'] -> Statement
With :: [WithItem] -> [Statement'] -> Statement
AsyncWith :: [WithItem] -> [Statement'] -> Statement

-- | <tt>Raise exc cause</tt> represents <tt>raise exc from cause</tt>.
Raise :: Maybe Expr' -> Maybe Expr' -> Statement

-- | <pre>
--   Try body handlers orelse finalbody
--   </pre>
Try :: [Statement'] -> [ExceptHandler'] -> [Statement'] -> [Statement'] -> Statement

-- | <pre>
--   Assert test msg
--   </pre>
Assert :: Expr' -> Maybe Expr' -> Statement
Import :: [Alias] -> Statement
ImportFrom :: [Ident'] -> [Alias] -> Statement
Global :: [Ident'] -> Statement
Nonlocal :: [Ident'] -> Statement
Expr' :: Expr' -> Statement
Pass :: Statement
Break :: Statement
Continue :: Statement
type Statement' = WithLoc Statement
data Expr
BoolOp :: Expr' -> BoolOp -> Expr' -> Expr

-- | produced by the walrus operator <tt>:=</tt>
NamedExpr :: Target' -> Expr' -> Expr
BinOp :: Expr' -> Operator -> Expr' -> Expr
UnaryOp :: UnaryOp -> Expr' -> Expr
Lambda :: Arguments -> Expr' -> Expr

-- | <pre>
--   IfExp test body orelse
--   </pre>
IfExp :: Expr' -> Expr' -> Expr' -> Expr

-- | NULL key is for <tt>**d</tt>.
Dict :: [(Maybe Expr', Expr')] -> Expr
Set :: [Expr'] -> Expr
ListComp :: Expr' -> [Comprehension] -> Expr
SetComp :: Expr' -> [Comprehension] -> Expr
DictComp :: Expr' -> Expr' -> [Comprehension] -> Expr
GeneratorExp :: Expr' -> [Comprehension] -> Expr
Await :: Expr' -> Expr
Yield :: Maybe Expr' -> Expr
YieldFrom :: Expr' -> Expr
Compare :: Expr' -> [(CmpOp, Expr')] -> Expr
Call :: Expr' -> [Expr'] -> [Keyword'] -> Expr

-- | <tt>FormattedValue value conversion format_spec</tt> for f-strings
FormattedValue :: Expr' -> Maybe Char -> Maybe Expr' -> Expr
JoinedStr :: [Expr'] -> Expr
Constant :: Constant -> Expr

-- | can appear in assignment context
Attribute :: Expr' -> Ident' -> Expr

-- | can appear in assignment context
Subscript :: Expr' -> Expr' -> Expr

-- | can appear in assignment context
Starred :: Expr' -> Expr

-- | can appear in assignment context
Name :: Ident' -> Expr

-- | can appear in assignment context
List :: [Expr'] -> Expr

-- | can appear in assignment context
Tuple :: [Expr'] -> Expr

-- | <tt>Slice lower upper step</tt> can appear only in Subscript
Slice :: Maybe Expr' -> Maybe Expr' -> Maybe Expr' -> Expr
type Expr' = WithLoc Expr
type Target = Expr'
type Target' = Expr'
type Type = Expr'
type Type' = Expr'
type Decorator = Expr'
type Decorator' = Expr'
data ExprContext
Load :: ExprContext
Store :: ExprContext
Del :: ExprContext
data BoolOp
And :: BoolOp
Or :: BoolOp

-- | our extension
Implies :: BoolOp
data Operator
Add :: Operator
Sub :: Operator
Mult :: Operator
MatMult :: Operator
Div :: Operator
FloorDiv :: Operator
FloorMod :: Operator

-- | our extension
CeilDiv :: Operator

-- | our extension
CeilMod :: Operator
Pow :: Operator
BitLShift :: Operator
BitRShift :: Operator
BitOr :: Operator
BitXor :: Operator
BitAnd :: Operator

-- | our extension
Max :: Operator

-- | our extension
Min :: Operator
data UnaryOp

-- | on int
Invert :: UnaryOp

-- | on bool
Not :: UnaryOp
UAdd :: UnaryOp
USub :: UnaryOp
data CmpOp
Eq' :: CmpOp
NotEq :: CmpOp
Lt :: CmpOp
LtE :: CmpOp
Gt :: CmpOp
GtE :: CmpOp
Is :: CmpOp
IsNot :: CmpOp
In :: CmpOp
NotIn :: CmpOp

-- | <pre>
--   Comprehension target iter ifs is_async
--   </pre>
data Comprehension
Comprehension :: Target' -> Expr' -> Maybe Expr' -> Comprehension
[compTarget] :: Comprehension -> Target'
[compIter] :: Comprehension -> Expr'
[compIfs] :: Comprehension -> Maybe Expr'
data ExceptHandler
ExceptHandler :: Maybe Type' -> Maybe Ident' -> [Statement'] -> ExceptHandler
[exchType] :: ExceptHandler -> Maybe Type'
[exchName] :: ExceptHandler -> Maybe Ident'
[exchBody] :: ExceptHandler -> [Statement']
type ExceptHandler' = WithLoc ExceptHandler
data Arguments
Arguments :: [Arg] -> [Arg] -> Maybe Arg -> [Arg] -> [Expr'] -> Maybe Arg -> [Expr'] -> Arguments
[argsPosonlyargs] :: Arguments -> [Arg]
[argsArgs] :: Arguments -> [Arg]
[argsVarargs] :: Arguments -> Maybe Arg
[argsKwonlyargs] :: Arguments -> [Arg]
[argsKwDefaults] :: Arguments -> [Expr']
[argsKwarg] :: Arguments -> Maybe Arg
[argsDefaults] :: Arguments -> [Expr']
emptyArguments :: Arguments
type Arg = (Ident', Maybe Type')

-- | NULL identifier is for <tt>**kwargs</tt>.
type Keyword = (Maybe Ident', Expr')
type Keyword' = WithLoc Keyword

-- | <tt>(name, asname)</tt>. <a>Alias</a> is used for <a>Import</a> and
--   <a>ImportFrom</a>.
type Alias = (Ident', Maybe Ident')

-- | <pre>
--   (context_expr, optional_vars)
--   </pre>
type WithItem = (Expr', Maybe Expr')
type Program = [Statement']
instance Data.String.IsString Jikka.Python.Language.Expr.Ident
instance GHC.Read.Read Jikka.Python.Language.Expr.Ident
instance GHC.Show.Show Jikka.Python.Language.Expr.Ident
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Ident
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Ident
instance GHC.Read.Read Jikka.Python.Language.Expr.Constant
instance GHC.Show.Show Jikka.Python.Language.Expr.Constant
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Constant
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Constant
instance GHC.Read.Read Jikka.Python.Language.Expr.ExprContext
instance GHC.Show.Show Jikka.Python.Language.Expr.ExprContext
instance GHC.Classes.Ord Jikka.Python.Language.Expr.ExprContext
instance GHC.Classes.Eq Jikka.Python.Language.Expr.ExprContext
instance GHC.Read.Read Jikka.Python.Language.Expr.BoolOp
instance GHC.Show.Show Jikka.Python.Language.Expr.BoolOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.BoolOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.BoolOp
instance GHC.Read.Read Jikka.Python.Language.Expr.Operator
instance GHC.Show.Show Jikka.Python.Language.Expr.Operator
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Operator
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Operator
instance GHC.Read.Read Jikka.Python.Language.Expr.UnaryOp
instance GHC.Show.Show Jikka.Python.Language.Expr.UnaryOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.UnaryOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.UnaryOp
instance GHC.Read.Read Jikka.Python.Language.Expr.CmpOp
instance GHC.Show.Show Jikka.Python.Language.Expr.CmpOp
instance GHC.Classes.Ord Jikka.Python.Language.Expr.CmpOp
instance GHC.Classes.Eq Jikka.Python.Language.Expr.CmpOp
instance GHC.Read.Read Jikka.Python.Language.Expr.Comprehension
instance GHC.Show.Show Jikka.Python.Language.Expr.Comprehension
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Comprehension
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Comprehension
instance GHC.Read.Read Jikka.Python.Language.Expr.Arguments
instance GHC.Show.Show Jikka.Python.Language.Expr.Arguments
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Arguments
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Arguments
instance GHC.Read.Read Jikka.Python.Language.Expr.Expr
instance GHC.Show.Show Jikka.Python.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Expr
instance GHC.Read.Read Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Show.Show Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Classes.Ord Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Classes.Eq Jikka.Python.Language.Expr.ExceptHandler
instance GHC.Read.Read Jikka.Python.Language.Expr.Statement
instance GHC.Show.Show Jikka.Python.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.Python.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.Python.Language.Expr.Statement

module Jikka.Python.Language.Util
constIntExp :: Integer -> Expr
constBoolExp :: Bool -> Expr
mapExprArgumentsM :: Monad m => (Expr' -> m Expr') -> Arguments -> m Arguments
mapExprComprehensionM :: Monad m => (Expr' -> m Expr') -> Comprehension -> m Comprehension
mapExprComprehensionsM :: Monad m => (Expr' -> m Expr') -> [Comprehension] -> m [Comprehension]
mapExprKeywordsM :: Monad m => (Expr' -> m Expr') -> [Keyword'] -> m [Keyword']
mapExprM :: Monad m => (Expr' -> m Expr') -> Expr' -> m Expr'
mapExprExceptHanderM :: Monad m => (Expr' -> m Expr') -> ExceptHandler' -> m ExceptHandler'
mapExprStatementM :: Monad m => (Expr' -> m Expr') -> Statement' -> m Statement'
mapExprStatementsM :: Monad m => (Expr' -> m Expr') -> [Statement'] -> m [Statement']
mapExprProgramM :: Monad m => (Expr' -> m Expr') -> Program -> m Program
mapExprProgram :: (Expr' -> Expr') -> Program -> Program


module Jikka.Python.Parse.Token
data CmpOp
DoubleEqual :: CmpOp
NotEqual :: CmpOp
LessThan :: CmpOp
LessEqual :: CmpOp
GreaterThan :: CmpOp
GreaterEqual :: CmpOp
data DivModOp
Div :: DivModOp
FloorDiv :: DivModOp
FloorMod :: DivModOp
CeilDiv :: DivModOp
CeilMod :: DivModOp
data AugOp
AugAdd :: AugOp
AugSub :: AugOp
AugMul :: AugOp
AugAt :: AugOp
AugDiv :: AugOp
AugFloorDiv :: AugOp
AugFloorMod :: AugOp
AugCeilDiv :: AugOp
AugCeilMod :: AugOp
AugPow :: AugOp
AugBitRShift :: AugOp
AugBitLShift :: AugOp
AugBitAnd :: AugOp
AugBitXor :: AugOp
AugBitOr :: AugOp
AugMin :: AugOp
AugMax :: AugOp

-- | We don't have to classify tokens in detail, but it's convenient for
--   testing and debugging.
data Token
None :: Token
Int :: Integer -> Token
Bool :: Bool -> Token
String :: String -> Token
Bytes :: [Int8] -> Token
Float :: Double -> Token
Imaginary :: Double -> Token
Def :: Token
If :: Token
Elif :: Token
Else :: Token
For :: Token
In :: Token
Assert :: Token
Return :: Token
Lambda :: Token
Arrow :: Token
Colon :: Token
Semicolon :: Token
Comma :: Token
Dot :: Token
Equal :: Token
Underscore :: Token
OpenBrace :: Token
OpenBracket :: Token
OpenParen :: Token
CloseBrace :: Token
CloseBracket :: Token
CloseParen :: Token
Ident :: String -> Token
WalrusOp :: Token
ImpliesOp :: Token
OrOp :: Token
AndOp :: Token
NotOp :: Token
CmpOp :: CmpOp -> Token
MinOp :: Token
MaxOp :: Token
BitOrOp :: Token
BitXorOp :: Token
BitAndOp :: Token
BitLShiftOp :: Token
BitRShiftOp :: Token
PlusOp :: Token
MinusOp :: Token
MulOp :: Token
DivModOp :: DivModOp -> Token
AtOp :: Token
BitNotOp :: Token
PowOp :: Token
AugOp :: AugOp -> Token
Newline :: Token
Indent :: Token
Dedent :: Token
As :: Token
Async :: Token
Await :: Token
Break :: Token
Class :: Token
Continue :: Token
Del :: Token
Except :: Token
Finally :: Token
From :: Token
Global :: Token
Import :: Token
Is :: Token
Nonlocal :: Token
Pass :: Token
Raise :: Token
Try :: Token
While :: Token
With :: Token
Yield :: Token
type Token' = WithLoc Token
instance GHC.Read.Read Jikka.Python.Parse.Token.CmpOp
instance GHC.Show.Show Jikka.Python.Parse.Token.CmpOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.CmpOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.CmpOp
instance GHC.Read.Read Jikka.Python.Parse.Token.DivModOp
instance GHC.Show.Show Jikka.Python.Parse.Token.DivModOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.DivModOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.DivModOp
instance GHC.Read.Read Jikka.Python.Parse.Token.AugOp
instance GHC.Show.Show Jikka.Python.Parse.Token.AugOp
instance GHC.Classes.Ord Jikka.Python.Parse.Token.AugOp
instance GHC.Classes.Eq Jikka.Python.Parse.Token.AugOp
instance GHC.Read.Read Jikka.Python.Parse.Token.Token
instance GHC.Show.Show Jikka.Python.Parse.Token.Token
instance GHC.Classes.Ord Jikka.Python.Parse.Token.Token
instance GHC.Classes.Eq Jikka.Python.Parse.Token.Token


module Jikka.Python.Parse.Happy
run :: MonadError Error m => [WithLoc Token] -> m Program


-- | <ul>
--   <li>TODO: tokenize float literals</li>
--   </ul>
module Jikka.Python.Parse.Alex
run :: MonadError Error m => String -> m [Token']
instance GHC.Show.Show Jikka.Python.Parse.Alex.AlexPosn
instance GHC.Classes.Eq Jikka.Python.Parse.Alex.AlexPosn
instance GHC.Base.Functor Jikka.Python.Parse.Alex.Alex
instance GHC.Base.Applicative Jikka.Python.Parse.Alex.Alex
instance GHC.Base.Monad Jikka.Python.Parse.Alex.Alex

module Jikka.Python.Parse
run :: MonadError Error m => FilePath -> Text -> m Program


module Jikka.RestrictedPython.Language.Expr
newtype TypeName
TypeName :: String -> TypeName
unTypeName :: TypeName -> String

-- | <a>Type</a> represents the types of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
--   
--   NOTE: &lt;math&gt; is represented as the 0-tuple.
data Type
VarTy :: TypeName -> Type
IntTy :: Type
BoolTy :: Type
ListTy :: Type -> Type
TupleTy :: [Type] -> Type
CallableTy :: [Type] -> Type -> Type
StringTy :: Type
SideEffectTy :: Type
pattern NoneTy :: Type
data UnaryOp

-- | on int
Invert :: UnaryOp

-- | on bool
Not :: UnaryOp
UAdd :: UnaryOp
USub :: UnaryOp
data Operator
Add :: Operator
Sub :: Operator
Mult :: Operator
MatMult :: Operator
Div :: Operator
FloorDiv :: Operator
FloorMod :: Operator

-- | our extension
CeilDiv :: Operator

-- | our extension
CeilMod :: Operator
Pow :: Operator
BitLShift :: Operator
BitRShift :: Operator
BitOr :: Operator
BitXor :: Operator
BitAnd :: Operator

-- | our extension
Max :: Operator

-- | our extension
Min :: Operator
data BoolOp
And :: BoolOp
Or :: BoolOp

-- | our extension
Implies :: BoolOp
data CmpOp
Eq' :: CmpOp
NotEq :: CmpOp
Lt :: CmpOp
LtE :: CmpOp
Gt :: CmpOp
GtE :: CmpOp
Is :: CmpOp
IsNot :: CmpOp
In :: CmpOp
NotIn :: CmpOp

-- | <a>CmpOp</a>` is a type for comparision operators. This is annotated
--   with its type as let-polymorphism.
data CmpOp'
CmpOp' :: CmpOp -> Type -> CmpOp'
data Constant
ConstNone :: Constant
ConstInt :: Integer -> Constant
ConstBool :: Bool -> Constant
ConstBuiltin :: Builtin -> Constant
data Builtin

-- | "abs" &lt;math&gt;
BuiltinAbs :: Builtin

-- | "pow" &lt;math&gt;
BuiltinPow :: Builtin

-- | modulo power "pow" &lt;math&gt;
BuiltinModPow :: Builtin

-- | "divmod" &lt;math&gt;
BuiltinDivMod :: Builtin

-- | ceil div &lt;math&gt;
BuiltinCeilDiv :: Builtin

-- | ceil mod &lt;math&gt;
BuiltinCeilMod :: Builtin

-- | floor div &lt;math&gt;
BuiltinFloorDiv :: Builtin

-- | floor mod &lt;math&gt;
BuiltinFloorMod :: Builtin

-- | &lt;math&gt;
BuiltinGcd :: Builtin

-- | &lt;math&gt;
BuiltinLcm :: Builtin

-- | "int" &lt;math&gt;
BuiltinInt :: Type -> Builtin

-- | "bool" &lt;math&gt;
BuiltinBool :: Type -> Builtin

-- | "list" &lt;math&gt;
BuiltinList :: Type -> Builtin

-- | "tuple" &lt;math&gt; where &lt;math&gt;
BuiltinTuple :: [Type] -> Builtin

-- | "len" &lt;math&gt;
BuiltinLen :: Type -> Builtin

-- | "map" &lt;math&gt;
BuiltinMap :: [Type] -> Type -> Builtin

-- | "sorted" &lt;math&gt;
BuiltinSorted :: Type -> Builtin

-- | "reversed" &lt;math&gt;
BuiltinReversed :: Type -> Builtin

-- | "enumerate" &lt;math&gt;
BuiltinEnumerate :: Type -> Builtin

-- | "filter" &lt;math&gt;
BuiltinFilter :: Type -> Builtin

-- | "zip" &lt;math&gt;
BuiltinZip :: [Type] -> Builtin

-- | "all" &lt;math&gt;
BuiltinAll :: Builtin

-- | "any" &lt;math&gt;
BuiltinAny :: Builtin

-- | "sum" &lt;math&gt;
BuiltinSum :: Builtin

-- | product &lt;math&gt;
BuiltinProduct :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange1 :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange2 :: Builtin

-- | "range" &lt;math&gt;
BuiltinRange3 :: Builtin

-- | "max" &lt;math&gt;
BuiltinMax1 :: Type -> Builtin

-- | "max" &lt;math&gt;
BuiltinMax :: Type -> Int -> Builtin

-- | "min" &lt;math&gt;
BuiltinMin1 :: Type -> Builtin

-- | "min" &lt;math&gt;
BuiltinMin :: Type -> Int -> Builtin

-- | &lt;math&gt;
BuiltinArgMax :: Type -> Builtin

-- | &lt;math&gt;
BuiltinArgMin :: Type -> Builtin

-- | factorial &lt;math&gt;
BuiltinFact :: Builtin

-- | &lt;math&gt;
BuiltinChoose :: Builtin

-- | &lt;math&gt;
BuiltinPermute :: Builtin

-- | &lt;math&gt;
BuiltinMultiChoose :: Builtin

-- | modulo inverse &lt;math&gt;
BuiltinModInv :: Builtin

-- | "input" &lt;math&gt;
BuiltinInput :: Builtin

-- | "print" &lt;math&gt;
BuiltinPrint :: [Type] -> Builtin
newtype AttributeName
AttributeName :: String -> AttributeName
unAttributeName :: AttributeName -> String
data Attribute
UnresolvedAttribute :: AttributeName -> Attribute

-- | "list.count" &lt;math&gt;
BuiltinCount :: Type -> Attribute

-- | "list.index" &lt;math&gt;
BuiltinIndex :: Type -> Attribute

-- | "list.copy" &lt;math&gt;
BuiltinCopy :: Type -> Attribute

-- | "list.append" &lt;math&gt;
BuiltinAppend :: Type -> Attribute

-- | "str.split" &lt;math&gt;
BuiltinSplit :: Attribute
type Attribute' = WithLoc' Attribute
newtype VarName
VarName :: String -> VarName
unVarName :: VarName -> String
type VarName' = WithLoc' VarName

-- | <a>Expr</a> represents the exprs of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
data Expr
BoolOp :: Expr' -> BoolOp -> Expr' -> Expr
BinOp :: Expr' -> Operator -> Expr' -> Expr
UnaryOp :: UnaryOp -> Expr' -> Expr
Lambda :: [(VarName', Type)] -> Expr' -> Expr
IfExp :: Expr' -> Expr' -> Expr' -> Expr
ListComp :: Expr' -> Comprehension -> Expr
Compare :: Expr' -> CmpOp' -> Expr' -> Expr
Call :: Expr' -> [Expr'] -> Expr
Constant :: Constant -> Expr
Attribute :: Expr' -> Attribute' -> Expr
Subscript :: Expr' -> Expr' -> Expr
Starred :: Expr' -> Expr
Name :: VarName' -> Expr
List :: Type -> [Expr'] -> Expr
Tuple :: [Expr'] -> Expr
SubscriptSlice :: Expr' -> Maybe Expr' -> Maybe Expr' -> Maybe Expr' -> Expr
type Expr' = WithLoc' Expr
data Comprehension
Comprehension :: Target' -> Expr' -> Maybe Expr' -> Comprehension

-- | <a>Target</a> represents the lvalue of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
data Target
SubscriptTrg :: Target' -> Expr' -> Target
NameTrg :: VarName' -> Target
TupleTrg :: [Target'] -> Target
type Target' = WithLoc' Target

-- | <a>Statement</a> represents the statements of our restricted
--   Python-like language. They appear in bodies of <tt>def</tt>.
--   
--   &lt;math&gt;
data Statement
Return :: Expr' -> Statement
AugAssign :: Target' -> Operator -> Expr' -> Statement
AnnAssign :: Target' -> Type -> Expr' -> Statement
For :: Target' -> Expr' -> [Statement] -> Statement
If :: Expr' -> [Statement] -> [Statement] -> Statement
Assert :: Expr' -> Statement

-- | expression statements
Expr' :: Expr' -> Statement
pattern Append :: Maybe Loc -> Type -> Expr' -> Expr' -> Statement

-- | <tt>TopLevelStatement</tt> represents the statements of our restricted
--   Python-like language. They appear in the toplevel of programs.
--   
--   &lt;math&gt;
data ToplevelStatement
ToplevelAnnAssign :: VarName' -> Type -> Expr' -> ToplevelStatement
ToplevelFunctionDef :: VarName' -> [(VarName', Type)] -> Type -> [Statement] -> ToplevelStatement
ToplevelAssert :: Expr' -> ToplevelStatement

-- | <a>Program</a> represents the programs of our restricted Python-like
--   language.
--   
--   &lt;math&gt;
type Program = [ToplevelStatement]
instance Data.String.IsString Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.VarName
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.VarName
instance Data.String.IsString Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.TypeName
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.TypeName
instance Data.String.IsString Jikka.RestrictedPython.Language.Expr.AttributeName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.AttributeName
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.AttributeName
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.AttributeName
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.AttributeName
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Type
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Builtin
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Constant
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Attribute
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Attribute
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Attribute
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Attribute
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.CmpOp'
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Target
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Comprehension
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Expr
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.Statement
instance GHC.Read.Read Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Show.Show Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Expr.ToplevelStatement
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Expr.ToplevelStatement

module Jikka.RestrictedPython.Language.Util
genType :: MonadAlpha m => m Type
genVarName :: MonadAlpha m => VarName' -> m VarName'
genVarName' :: MonadAlpha m => m VarName'
freeTyVars :: Type -> [TypeName]

-- | <a>freeVars</a>` reports all free variables.
freeVars :: Expr' -> [VarName]

-- | <a>freeVars</a>` reports all free variables with their locations, i.e.
--   occurrences. For examples, <tt>x + x</tt> and <tt>x</tt> have the same
--   free variables <tt>x</tt> but they have different sets of occurrences
--   of free variable.
freeVars' :: Expr' -> [VarName']
freeVarsTarget :: Target' -> [VarName]
freeVarsTarget' :: Target' -> [VarName']
doesAlwaysReturn :: Statement -> Bool
doesPossiblyReturn :: Statement -> Bool
mapStatement :: (Statement -> [Statement]) -> Program -> Program

-- | <a>mapStatementM</a> replaces all statements in a given program using
--   a given function. This may breaks various constraints.
mapStatementM :: Monad m => (Statement -> m [Statement]) -> Program -> m Program
mapLargeStatement :: (Expr' -> [Statement] -> [Statement] -> [Statement]) -> (Target' -> Expr' -> [Statement] -> [Statement]) -> Program -> Program
mapLargeStatementM :: Monad m => (Expr' -> [Statement] -> [Statement] -> m [Statement]) -> (Target' -> Expr' -> [Statement] -> m [Statement]) -> Program -> m Program
mapStatements :: ([Statement] -> [Statement]) -> Program -> Program
mapStatementsM :: Monad m => ([Statement] -> m [Statement]) -> Program -> m Program
listStatements :: Program -> [Statement]

-- | <a>mapSubExprM</a> replaces all exprs in a given expr using a given
--   function. This may breaks various constraints.
mapSubExprM :: Monad m => (Expr' -> m Expr') -> Expr' -> m Expr'
mapSubExpr :: (Expr' -> Expr') -> Expr' -> Expr'
listSubExprs :: Expr' -> [Expr']
mapExprTargetM :: Monad m => (Expr' -> m Expr') -> Target' -> m Target'
mapExprStatementM :: Monad m => (Expr' -> m Expr') -> Statement -> m Statement
mapExprM :: Monad m => (Expr' -> m Expr') -> Program -> m Program
listExprs :: Program -> [Expr']
hasFunctionCall :: Expr' -> Bool

-- | <a>isSmallExpr</a> is true if the evaluation of a given expr trivially
--   terminates.
isSmallExpr :: Expr' -> Bool
dropLocation :: Expr' -> Expr'
targetVars :: Target' -> [VarName]
targetVars' :: Target' -> [VarName']
hasSubscriptTrg :: Target' -> Bool
hasBareNameTrg :: Target' -> Bool
exprToTarget :: Expr' -> Maybe Target'
targetToExpr :: Target' -> Expr'
toplevelMainDef :: [Statement] -> Program

module Jikka.RestrictedPython.Language.Builtin
builtinNames :: Set VarName
standardBuiltinNames :: Set VarName
additionalBuiltinNames :: Set VarName

-- | <a>resolveUniqueBuiltin</a> makes a builtin function from a variable
--   name. However, this doesn't anything for ambiguous builtin functions.
--   For example, the builtin function "max" is kept as a variable because
--   it may be &lt;math&gt;, &lt;math&gt;, etc. and this function cannot
--   resolve it.
resolveUniqueBuiltin :: (MonadAlpha m, MonadError Error m) => VarName' -> m Expr'
resolveBuiltin :: (MonadAlpha m, MonadError Error m) => VarName' -> Int -> m Expr'
formatBuiltin :: Builtin -> String
typeBuiltin :: Builtin -> Type
mapTypeBuiltin :: (Type -> Type) -> Builtin -> Builtin
attributeNames :: Set AttributeName
resolveAttribute' :: (MonadAlpha m, MonadError Error m) => Attribute' -> m Attribute'
resolveAttribute :: (MonadAlpha m, MonadError Error m) => Expr' -> Attribute' -> m Expr
formatAttribute :: Attribute -> String
typeAttribute :: Attribute -> (Type, Type)
mapTypeAttribute :: (Type -> Type) -> Attribute -> Attribute


module Jikka.RestrictedPython.Format
run :: Applicative m => Program -> m Text
run' :: Program -> String
formatType :: Type -> String
formatOperator :: Operator -> String
formatBuiltin :: Builtin -> String
formatAttribute :: Attribute -> String
formatExpr :: Expr' -> String
formatTarget :: Target' -> String


module Jikka.RestrictedPython.Convert.UseAppend

-- | <a>run</a> converts <tt>xs = xs + [x]</tt> and <tt>xs += [x]</tt> to
--   <tt>xs.append(x)</tt>.
--   
--   <h2>Examples</h2>
--   
--   Before:
--   
--   <pre>
--   xs = xs + [x]
--   xs += [x]
--   xs.append(x)
--   </pre>
--   
--   After:
--   
--   <pre>
--   xs.append(x)
--   xs.append(x)
--   xs.append(x)
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.RestrictedPython.Convert.TypeInfer

-- | <a>run</a> infers types of given programs.
--   
--   As the interface, you can understand this function does the following:
--   
--   <ol>
--   <li>Finds a type environment &lt;math&gt; s.t. for all statement
--   &lt;math&gt; in the given program, &lt;math&gt; holds, and</li>
--   <li>Annotates each variable in the program using the
--   &lt;math&gt;.</li>
--   </ol>
--   
--   In its implementation, this is just something like a Hindley-Milner
--   type inference.
--   
--   <h2>Requirements</h2>
--   
--   <ul>
--   <li>There must be no name conflicts in given programs. They must be
--   alpha-converted. (<a>Alpha</a>)</li>
--   <li>All names must be resolved. (<a>ResolveBuiltin</a>)</li>
--   </ul>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
data Equation
TypeEquation :: Type -> Type -> Maybe Loc -> Equation
TypeAssertion :: VarName' -> Type -> Equation
formularizeProgram :: MonadAlpha m => Program -> m [Equation]
sortEquations :: [Equation] -> ([(Type, Type, Maybe Loc)], [(VarName', Type)])
mergeAssertions :: [(VarName', Type)] -> [(Type, Type, Maybe Loc)]

-- | <a>Subst</a> is type substituion. It's a mapping from type variables
--   to their actual types.
newtype Subst
Subst :: Map TypeName Type -> Subst
[unSubst] :: Subst -> Map TypeName Type
subst :: Subst -> Type -> Type
solveEquations :: MonadError Error m => [(Type, Type, Maybe Loc)] -> m Subst
mapTypeProgram :: (Type -> Type) -> Program -> Program
instance GHC.Read.Read Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Show.Show Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Classes.Ord Jikka.RestrictedPython.Convert.TypeInfer.Equation
instance GHC.Classes.Eq Jikka.RestrictedPython.Convert.TypeInfer.Equation


module Jikka.RestrictedPython.Convert.RemoveUnreachable

-- | <a>run</a> removes unreachable statements after return-statements.
--   
--   For example, the following
--   
--   <pre>
--   a = 0
--   if True:
--       b = 0
--       return b
--       b += 1
--   else:
--       return 1
--   a += 1
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   a = 0
--   if True:
--       b = 0
--       return b
--   else:
--       return 1
--   </pre>
run :: Program -> Program


module Jikka.RestrictedPython.Convert.RemoveUnbalancedIf

-- | <a>run</a> removes if-statements that one branch always returns and
--   the other branch doesn't.
--   
--   For example, the following
--   
--   <pre>
--   if True:
--       return 0
--   else:
--       a = 0
--   b = 1
--   return 2
--   </pre>
--   
--   is converted to
--   
--   <pre>
--   if True:
--       return 0
--   else:
--       a = 0
--       b = 1
--       return 2
--   </pre>
run :: Program -> Program


module Jikka.RestrictedPython.Convert.ParseMain
run :: (MonadAlpha m, MonadError Error m) => Program -> m (Maybe IOFormat, Program)


module Jikka.RestrictedPython.Convert.DefaultMain
run :: (MonadAlpha m, MonadError Error m) => Program -> m IOFormat


module Jikka.Python.Convert.ToRestrictedPython
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

module Jikka.RestrictedPython.Language.Value

-- | <a>Value</a> is the values of our restricted Python-like language.
--   
--   &lt;math&gt;
data Value
IntVal :: Integer -> Value
BoolVal :: Bool -> Value
ListVal :: Vector Value -> Value
TupleVal :: [Value] -> Value
ClosureVal :: Local -> [(VarName, Type)] -> [Statement] -> Value
BuiltinVal :: Builtin -> Value
AttributeVal :: Value -> Attribute -> Value
newtype Local
Local :: Map VarName Value -> Local
[unLocal] :: Local -> Map VarName Value
toInt :: MonadError Error m => Value -> m Integer
toBool :: MonadError Error m => Value -> m Bool
toList :: MonadError Error m => Value -> m (Vector Value)
toTuple :: MonadError Error m => Value -> m [Value]
toIntList :: MonadError Error m => Value -> m (Vector Integer)
toBoolList :: MonadError Error m => Value -> m (Vector Bool)
toMatrix :: MonadError Error m => Value -> m (Matrix Integer)
fromMatrix :: Matrix Integer -> Value
compareValues :: Value -> Value -> Maybe Ordering
compareValues' :: Value -> Value -> Ordering
formatValue :: Value -> String
readValueIO :: (MonadIO m, MonadError Error m) => IOFormat -> m ([Value], Map String Value)
writeValueIO :: (MonadError Error m, MonadIO m) => IOFormat -> Map String Value -> Value -> m ()
instance GHC.Read.Read Jikka.RestrictedPython.Language.Value.Value
instance GHC.Show.Show Jikka.RestrictedPython.Language.Value.Value
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Value.Value
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Value.Value
instance GHC.Read.Read Jikka.RestrictedPython.Language.Value.Local
instance GHC.Show.Show Jikka.RestrictedPython.Language.Value.Local
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.Value.Local
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.Value.Local

module Jikka.RestrictedPython.Language.VariableAnalysis
newtype ReadList
ReadList :: [VarName] -> ReadList
newtype WriteList
WriteList :: [VarName] -> WriteList
haveWriteReadIntersection :: WriteList -> ReadList -> Bool
analyzeExpr :: Expr' -> ReadList
analyzeTargetRead :: Target' -> ReadList
analyzeTargetWrite :: Target' -> WriteList
analyzeStatementGeneric :: Bool -> Statement -> (ReadList, WriteList)
analyzeStatementsGeneric :: Bool -> [Statement] -> (ReadList, WriteList)

-- | <a>analyzeStatementMax</a> returns lists of variables which are
--   possibly read or written in given statements.
analyzeStatementMax :: Statement -> (ReadList, WriteList)
analyzeStatementsMax :: [Statement] -> (ReadList, WriteList)

-- | <a>analyzeStatementMin</a> returns lists of variables which are always
--   read or written in given statements.
analyzeStatementMin :: Statement -> (ReadList, WriteList)
analyzeStatementsMin :: [Statement] -> (ReadList, WriteList)
instance GHC.Read.Read Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Show.Show Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.VariableAnalysis.ReadList
instance GHC.Read.Read Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Show.Show Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Classes.Ord Jikka.RestrictedPython.Language.VariableAnalysis.WriteList
instance GHC.Classes.Eq Jikka.RestrictedPython.Language.VariableAnalysis.WriteList

module Jikka.RestrictedPython.Language.Lint
makeEnsureProgram :: MonadError Error m => (Program -> Bool) -> String -> Program -> m ()

-- | <a>hasSubscriptionInLoopCounters</a> checks that there are
--   <a>SubscriptTrg</a> in loop counters of for-loops. This includes loop
--   counters of <a>ListComp</a>. For example, the followings has such
--   subscriptions.
--   
--   <pre>
--   for a[0] in range(100):
--       pass
--   return a[0]  # =&gt; 99
--   </pre>
--   
--   <pre>
--   a = [0]
--   b = [0 for a[0] in range(100)]
--   return a[0]  # =&gt; 99
--   </pre>
--   
--   NOTE: This is allowd in the standard Python.
hasSubscriptionInLoopCounters :: Program -> Bool
doesntHaveSubscriptionInLoopCounters :: Program -> Bool
ensureDoesntHaveSubscriptionInLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasLeakOfLoopCounters</a> checks that there are leaks of loop
--   counters of for-loops. For example, the following has a leak.
--   
--   <pre>
--   for i in range(100):
--       pass
--   return i  # =&gt; 100
--   </pre>
hasLeakOfLoopCounters :: Program -> Bool
doesntHaveLeakOfLoopCounters :: Program -> Bool
ensureDoesntHaveLeakOfLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasAssignmentToLoopCounters</a> checks that there are assignments
--   to loop counters of for-loops. For example, the following has the
--   assignment.
--   
--   <pre>
--   for i in range(100):
--       i += 1
--   </pre>
hasAssignmentToLoopCounters :: Program -> Bool
doesntHaveAssignmentToLoopCounters :: Program -> Bool
ensureDoesntHaveAssignmentToLoopCounters :: MonadError Error m => Program -> m ()

-- | <a>hasAssignmentToLoopIterators</a> checks that there are assignments
--   to loop iterators of for-loops. For example, the followings have the
--   assignments.
--   
--   <pre>
--   a = list(range(10))
--   for i in a:
--       a[5] = i
--   </pre>
--   
--   <pre>
--   a = 0
--   for i in f(a):
--       a += i
--   </pre>
hasAssignmentToLoopIterators :: Program -> Bool
doesntHaveAssignmentToLoopIterators :: Program -> Bool
ensureDoesntHaveAssignmentToLoopIterators :: MonadError Error m => Program -> m ()

-- | <a>hasReturnInLoops</a> checks that there are return-statements in
--   for-loops. For example, the following has such a return-statement.
--   
--   <pre>
--   a = list(range(10))
--   for i in a:
--       return True
--   </pre>
hasReturnInLoops :: Program -> Bool
doesntHaveReturnInLoops :: Program -> Bool
ensureDoesntHaveReturnInLoops :: MonadError Error m => Program -> m ()

-- | <a>hasMixedAssignment</a> checks that there are assignments which
--   assign to both of bare variables and subscripted variables. For
--   example, the following is such an assignment.
--   
--   <pre>
--   a, b[0] = list(range(10))
--   </pre>
--   
--   NOTE: this doesn't check loop counters of <a>For</a> or
--   <a>ListComp</a>.
hasMixedAssignment :: Program -> Bool
doesntHaveMixedAssignment :: Program -> Bool
ensureDoesntHaveMixedAssignment :: MonadError Error m => Program -> m ()

-- | <a>hasNonTrivialSubscriptedAssignmentInForLoops</a> checks that there
--   are assignments with non-trivial subscriptions in for-loops. A trivial
--   subscription is a sequence of subscriptions to a variable with
--   constant indices and at most one trivial loop-counter indices for each
--   loops. A constant index is an expr which has a constant value in the
--   loop. A trivial loop-counter index is the loop counter from
--   "range(n)", "range(n, m)" or "enumerate(a)" with optional
--   post-addition with a positive int literal.
--   
--   For example, the followings have such assignments.
--   
--   <pre>
--   x = 0
--   for i in range(10):
--       x += 1
--       a[x] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       j = i
--       a[j] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[2 * i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[1 + i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i - 1] += 1
--   </pre>
--   
--   <pre>
--   c = 1
--   for i in range(10):
--       a[i + c] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i][i] += 1
--   </pre>
--   
--   <pre>
--   for i in [1, 2, 3]:
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   b = range(10)
--   for i in b:
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(0, 10, 2):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i, b_i in enumerate(b):
--       a[b_i] += i
--   </pre>
--   
--   For example, the followings don't have such assignments.
--   
--   <pre>
--   c = 0
--   for i in range(10):
--       a[c] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a[i + 1] += 1
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       for j in range(10):
--           a[i + 1][j] += 1
--   </pre>
--   
--   <pre>
--   for i in range(1, 10):
--       a[i] += 1
--   </pre>
--   
--   <pre>
--   for i, b_i in enumerate(b):
--       a[i] += b_i
--   </pre>
hasNonTrivialSubscriptedAssignmentInForLoops :: Program -> Bool
doesntHaveNonTrivialSubscriptedAssignmentInForLoops :: Program -> Bool
ensureDoesntHaveNonTrivialSubscriptedAssignmentInForLoops :: MonadError Error m => Program -> m ()

-- | <tt>hasAssginmentToBuiltin</tt> checks that there are assignments to
--   builtin functions. For example, the followings have such assignments.
--   
--   <pre>
--   map = 3
--   </pre>
--   
--   <pre>
--   return [range for range in range(10)]
--   </pre>
hasAssignmentToBuiltin :: Program -> Bool
doesntHaveAssignmentToBuiltin :: Program -> Bool
ensureDoesntHaveAssignmentToBuiltin :: MonadError Error m => Program -> m ()

-- | <a>hasNonResolvedBuiltin</a> checks that there are not resolved
--   builtin functions. This always doesn't hold after
--   <a>ResolveBuiltin</a>.
hasNonResolvedBuiltin :: Program -> Bool
doesntHaveNonResolvedBuiltin :: Program -> Bool
ensureDoesntHaveNonResolvedBuiltin :: MonadError Error m => Program -> m ()


module Jikka.RestrictedPython.Evaluate
run :: MonadError Error m => Program -> [Value] -> m Value

-- | <a>makeGlobal</a> packs toplevel definitions into <a>Global</a>. This
--   assumes <a>doesntHaveLeakOfLoopCounters</a>.
makeGlobal :: MonadError Error m => Program -> m Global
runWithGlobal :: MonadError Error m => Global -> Expr' -> m Value

-- | <a>evalExpr</a> evaluates exprs of our restricted Python-like
--   language.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt; &lt;math&gt; &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt; &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   <h3>Rules for &lt;math&gt;</h3>
evalExpr :: (MonadReader Global m, MonadState Local m, MonadError Error m) => Expr' -> m Value

-- | <a>evalStatement</a> evaluates statements of our restricted
--   Python-like language. When a statement is evaluated, it returns a
--   value &lt;math&gt;, doesn't return anything &lt;math&gt;, or fails
--   &lt;math&gt;. Also it updates the environment function &lt;math&gt;
--   from variables to values.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   It assumes the program is properly alpha-converted, i.e.
--   <a>doesntHaveLeakOfLoopCounters</a>. So it leaks loop counters to out
--   of loops.
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   <h3>Rules for &lt;math&gt;</h3>
--   
--   &lt;math&gt;
evalStatement :: (MonadReader Global m, MonadState Local m, MonadError Error m) => Statement -> m (Maybe Value)

-- | <a>evalStatements</a> evaluates sequences of statements of our
--   restricted Python-like language.
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
--   
--   &lt;math&gt;
evalStatements :: (MonadReader Global m, MonadState Local m, MonadError Error m) => [Statement] -> m (Maybe Value)
execToplevelStatement :: (MonadState Global m, MonadError Error m) => ToplevelStatement -> m ()
instance GHC.Read.Read Jikka.RestrictedPython.Evaluate.Global
instance GHC.Show.Show Jikka.RestrictedPython.Evaluate.Global
instance GHC.Classes.Ord Jikka.RestrictedPython.Evaluate.Global
instance GHC.Classes.Eq Jikka.RestrictedPython.Evaluate.Global


module Jikka.RestrictedPython.Convert.ResolveBuiltin

-- | <a>run</a> resolves types of polymorphic builtin functions. This
--   assumes there are no assignments to builtin functions, i.e.
--   <a>doesntHaveAssignmentToBuiltin</a>.
--   
--   For example, the <tt>max</tt> of <tt>max(xs)</tt> has a type
--   &lt;math&gt; but the <tt>max</tt> of <tt>max(x, y, z)</tt> has a type
--   &lt;math&gt;. So this function converts <tt>Var "max"</tt> to
--   <tt>BuiltinMax1 t</tt>, <tt>BuiltinMax t 2</tt>, <tt>BuiltinMax t
--   3</tt>, etc..
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program


module Jikka.RestrictedPython.Convert.ToCore

-- | <a>run</a> converts programs of our restricted Python-like language to
--   programs of our core language. This assumes the follwing conditions:
--   
--   <ul>
--   <li><a>doesntHaveSubscriptionInLoopCounters</a></li>
--   <li><a>doesntHaveLeakOfLoopCounters</a></li>
--   <li><a>doesntHaveAssignmentToLoopCounters</a></li>
--   <li><a>doesntHaveAssignmentToLoopIterators</a></li>
--   <li><a>doesntHaveReturnInLoops</a></li>
--   <li><a>doesntHaveNonTrivialSubscriptedAssignmentInForLoops</a></li>
--   </ul>
--   
--   For example, this converts the following:
--   
--   <pre>
--   def solve(n):
--       if n == 0:
--           return 1
--       else:
--           return n * solve(n - 1)
--   </pre>
--   
--   to:
--   
--   <pre>
--   let solve n =
--       if n == 0 then
--           1
--       else:
--           n * solve (n - 1)
--   in solve
--   </pre>
--   
--   Also, this converts the following:
--   
--   <pre>
--   def solve(n):
--       a = 0
--       b = 1
--       for _ in range(n):
--           c = a + b
--           a = b
--           b = c
--       return a
--   </pre>
--   
--   to:
--   
--   <pre>
--   let solve n =
--       fst (foldl (fun (a, b) i -&gt; (b, a + b)) (0, 1) [0 .. n - 1])
--   in solve
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | <a>runForStatement</a> converts for-loops to <a>foldl</a>. For
--   example, this converts the following:
--   
--   <pre>
--   # a, b are defined
--   for _ in range(n):
--       c = a + b
--       a = b
--       b = c
--   ...
--   </pre>
--   
--   to:
--   
--   <pre>
--   let (a, b) = foldl (fun (a, b) i -&gt; (b, a + b)) (a, b) (range n)
--   in ...
--   </pre>
runForStatement :: (MonadState Env m, MonadAlpha m, MonadError Error m) => Target' -> Expr' -> [Statement] -> [Statement] -> [[Statement]] -> m Expr

-- | <a>runIfStatement</a> converts if-loops to if-exprs.
--   
--   <pre>
--   # a, b are defined
--   if True:
--       a = 0
--       b = 1
--       c = 3
--   else:
--       a = 1
--       c = 10
--   ...
--   </pre>
--   
--   to:
--   
--   <pre>
--   let (a, c) = if true then (0, 3) else (1, 10)
--   in ...
--   </pre>
runIfStatement :: (MonadState Env m, MonadAlpha m, MonadError Error m) => Expr' -> [Statement] -> [Statement] -> [Statement] -> [[Statement]] -> m Expr


module Jikka.RestrictedPython.Convert.Alpha

-- | <a>run</a> renames variables. This assumes
--   <a>doesntHaveAssignmentToBuiltin</a>.
--   
--   <ul>
--   <li>This introduce a new name for each assignment if possible. For
--   example, the following</li>
--   </ul>
--   
--   <pre>
--   x = 21
--   x += x
--   x = 42
--   x += x
--   for _ in range(100):
--       x = x + 1
--   x = x + 1
--   </pre>
--   
--   turns the following
--   
--   <pre>
--   x0 = 21
--   x1 += x0
--   x2 = 42
--   x3 += x2
--   for a4 in range(100):
--       x3 = x3 + 1
--   x5 = x3 + 1
--   </pre>
--   
--   <ul>
--   <li>This blames leaks of loop counters of for-statements, i.e.
--   <a>doesntHaveLeakOfLoopCounters</a>. For example, the followings is
--   not allowed.</li>
--   </ul>
--   
--   <pre>
--   for i in range(10):
--       a = 0
--   return a  # error
--   </pre>
--   
--   <ul>
--   <li>This blames leaks of names from for-statements and if-statements
--   at all. For example, the followings are not allowed.</li>
--   </ul>
--   
--   <pre>
--   if True:
--       a = 0
--   else:
--       b = 1
--   return a  # error
--   </pre>
--   
--   <pre>
--   for i in range(10):
--       a = 0
--   return a  # error
--   </pre>
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program
instance GHC.Show.Show Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Read.Read Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Classes.Ord Jikka.RestrictedPython.Convert.Alpha.Env
instance GHC.Classes.Eq Jikka.RestrictedPython.Convert.Alpha.Env


module Jikka.RestrictedPython.Convert.SplitLoops

-- | <a>run</a> does alpha conversion, check assumptions, and <a>run</a>`.
run :: (MonadAlpha m, MonadError Error m) => Program -> m Program

-- | <a>run</a>` splits for-loops into many small for-loops as possible.
--   This assumes that <a>doesntHaveSubscriptionInLoopCounters</a>,
--   <a>doesntHaveAssignmentToLoopCounters</a>, and
--   <a>doesntHaveAssignmentToLoopIterators</a> hold. This may introduce
--   name conflicts.
--   
--   For example, the following
--   
--   <pre>
--   a = 0
--   b = 0
--   for i in range(10):
--       c = b
--       a += i
--       b += c
--   </pre>
--   
--   is split to
--   
--   <pre>
--   a = 0
--   b = 0
--   for i in range(10):
--       c = b
--       b += c
--   for i in range(10):
--       a += i
--   </pre>
run' :: Program -> Program

-- | <a>runForLoop</a> splits a for-loop to many for-loops as possible.
--   This assumes that <a>doesntHaveSubscriptionInLoopCounters</a>,
--   <a>doesntHaveAssignmentToLoopCounters</a>, and
--   <a>doesntHaveAssignmentToLoopIterators</a> hold.
--   
--   This function analyzes read-variables and write-variables in
--   statements, and split statements into connected components.
runForLoop :: Target' -> Expr' -> [Statement] -> [Statement]

module Jikka.RestrictedPython.Convert
run :: (MonadAlpha m, MonadError Error m) => Program -> m (Program, IOFormat)
run' :: (MonadAlpha m, MonadError Error m) => Program -> m (Program, IOFormat)


module Jikka.Main.Subcommand.Execute
run :: Target -> FilePath -> ExceptT Error IO ()

module Jikka.Main.Subcommand.Debug
run :: FilePath -> ExceptT Error IO ()


module Jikka.Main.Subcommand.Convert
run :: Target -> FilePath -> Text -> Either Error Text

module Jikka.RestrictedPython.Language.WithoutLoc
constIntExp :: Integer -> Expr'
constBoolExp :: Bool -> Expr'
constBuiltinExp :: Builtin -> Expr'
binOp :: Expr' -> Operator -> Expr' -> Expr'
addExp :: Expr' -> Expr' -> Expr'
subExp :: Expr' -> Expr' -> Expr'
multExp :: Expr' -> Expr' -> Expr'
unaryOp :: UnaryOp -> Expr' -> Expr'
eqExp :: Type -> Expr' -> Expr' -> Expr'
name :: VarName' -> Expr'
call :: Expr' -> [Expr'] -> Expr'
list :: Type -> [Expr'] -> Expr'
listComp :: Expr' -> Comprehension -> Expr'
subscript :: Expr' -> Expr' -> Expr'
nameTrg :: VarName' -> Target'
subscriptTrg :: Target' -> Expr' -> Target'
tupleTrg :: [Target'] -> Target'


module Jikka.CPlusPlus.Convert.BundleRuntime

-- | <a>run</a> bundles runtime headers to C++ code like <a>`oj-bundle`
--   command</a>.
run :: (MonadIO m, MonadError Error m) => Text -> m Text
instance GHC.Read.Read Jikka.CPlusPlus.Convert.BundleRuntime.PreprocessorState
instance GHC.Show.Show Jikka.CPlusPlus.Convert.BundleRuntime.PreprocessorState
instance GHC.Classes.Ord Jikka.CPlusPlus.Convert.BundleRuntime.PreprocessorState
instance GHC.Classes.Eq Jikka.CPlusPlus.Convert.BundleRuntime.PreprocessorState


module Jikka.Main
data Flag
Help :: Flag
Verbose :: Flag
Version :: Flag
Target :: String -> Flag
BundleRuntimeHeaders :: Bool -> Flag
EmbedOriginalCode :: Bool -> Flag
data Options
Options :: Bool -> Maybe Target -> Bool -> Bool -> Options
[verbose] :: Options -> Bool
[target] :: Options -> Maybe Target
[bundleRuntimeHeaders] :: Options -> Bool
[embedOriginalCode] :: Options -> Bool
defaultOptions :: Options
header :: String -> String
options :: [OptDescr Flag]
main :: String -> [String] -> IO ExitCode
parseFlags :: String -> [Flag] -> Either Error Options
runSubcommand :: String -> Options -> FilePath -> ExceptT Error IO ()
instance GHC.Read.Read Jikka.Main.Flag
instance GHC.Show.Show Jikka.Main.Flag
instance GHC.Classes.Ord Jikka.Main.Flag
instance GHC.Classes.Eq Jikka.Main.Flag
instance GHC.Read.Read Jikka.Main.Options
instance GHC.Show.Show Jikka.Main.Options
instance GHC.Classes.Ord Jikka.Main.Options
instance GHC.Classes.Eq Jikka.Main.Options
