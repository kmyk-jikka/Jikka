{"examples": [{"path": "examples/abc200_b.py", "python": "# https://atcoder.jp/contests/abc200/tasks/abc200_b\n\nfrom typing import *\n\ndef solve(n: int, k: int) -> int:\n    for _ in range(k):\n        if n % 200 == 0:\n            n //= 200\n        else:\n            n = n*1000 + 200\n    return n\n\ndef main() -> None:\n    n, k = map(int, input().split())\n    ans = solve(n, k)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, k: int) -> int:\n    for _ in range(k):\n        if n % 200 == 0:\n            n //= 200\n        else:\n            n: $1 = n * 1000 + 200\n    return n\ndef main() -> None:\n    n, k: $2 = map(int, input().split())\n    ans: $3 = solve(n, k)\n    print(ans)\n", "core": "fun (n$25: int) (k$26: int) ->\n    iterate k$26 (fun ($30: int) ->\n        if $30 % 200 == 0 then $30 / 200 else $30 * 1000 + 200\n    ) n$25\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t k) {\n  for (int32_t i = 0; i < int32_t(k); ++i) {\n    n = jikka::floormod(n, 200ll) == 0ll ? jikka::floordiv(n, 200ll)\n                                         : n * 1000ll + 200ll;\n  }\n  return n;\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  auto x3 = solve(x, x2);\n  std::cout << x3 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/abc203_b.py", "python": "# https://atcoder.jp/contests/abc203/tasks/abc203_b\n\n# from typing import *\n\ndef solve(n: int, k: int) -> int:\n    a = []\n    for i in range(1,n+1):\n        for j in range(1,k+1):\n            a.append(100*i + j)   \n    ans = sum(a)\n    return ans\n\ndef main() -> None:\n    n, k = map(int, input().split())\n    ans = solve(n, k)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, k: int) -> int:\n    a: $0 = []\n    for i in range(1, n + 1):\n        for j in range(1, k + 1):\n            a.append(100 * i + j)\n    ans: $2 = sum(a)\n    return ans\ndef main() -> None:\n    n, k: $3 = map(int, input().split())\n    ans: $4 = solve(n, k)\n    print(ans)\n", "core": "fun (n$40: int) (k$41: int) ->\n    sum (foldl (fun ($119: int list) ($120: int) ->\n        foldl (fun ($116: int list) ($117: int) ->\n            snoc $116 ($117 + $120 * 100 + 101)\n        ) $119 (range k$41)\n    ) nil (range n$40))\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t k) {\n  std::vector<int64_t> x;\n  for (int32_t i = 0; i < n; ++i) {\n    for (int32_t i2 = 0; i2 < k; ++i2) {\n      x.push_back(i2 + i * 100ll + 101ll);\n    }\n  }\n  int64_t sum = std::accumulate(x.begin(), x.end(), 0ll);\n  return sum;\n}\nint main() {\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  std::cin >> x2;\n  std::cin >> x3;\n  auto x4 = solve(x2, x3);\n  std::cout << x4 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/abc204_b.py", "python": "# https://atcoder.jp/contests/abc204/tasks/abc204_b\n\nfrom typing import *\n\ndef solve(n: int, a: List[int]) -> int:\n    ans = 0\n    for e in a:\n        if e > 10:\n            ans += e - 10\n    return ans\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(n, a)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, a: List[int]) -> int:\n    ans: $0 = 0\n    for e in a:\n        if e > 10:\n            ans += e - 10\n    return ans\ndef main() -> None:\n    n: $2 = int(input())\n    a: $3 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $5 = solve(n, a)\n    print(ans)\n", "core": "const (fun (a$33: int list) ->\n    foldl (fun ($39: int) ($38: int) ->\n        if - $38 + 10 < 0 then $38 + $39 - 10 else $39\n    ) 0 a$33\n)\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> a) {\n  int64_t x = 0ll;\n  for (int64_t x2 : a) {\n    x = -x2 + 10ll < 0ll ? x2 + x - 10ll : x;\n  }\n  return x;\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  std::vector<int64_t> x4(x3, -1ll);\n  for (int32_t i = 0; i < x3; ++i) {\n    std::cin >> x4[i];\n  }\n  auto x5 = solve(x3, x4);\n  std::cout << x5 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/abc206_b.py", "python": "# https://atcoder.jp/contests/abc206/tasks/abc206_b\n\n# from typing import *\n\ndef solve(n: int) -> int:\n    c = 0\n    ans = 0\n    flag = True\n    for i in range(100000): # (10^5)^2 > 10^9\n        c += i\n        if c >= n and flag:\n            ans = i\n            flag = False\n    return ans\n\ndef main() -> None:\n    n = int(input())\n    ans = solve(n)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int) -> int:\n    c: $0 = 0\n    ans: $1 = 0\n    flag: $2 = True\n    for i in range(100000):\n        c += i\n        if c >= n and flag:\n            ans: $4 = i\n            flag: $5 = False\n    return ans\ndef main() -> None:\n    n: $6 = int(input())\n    ans: $7 = solve(n)\n    print(ans)\n", "core": "fun (n$36: int) ->\n    (foldl (fun ($46: bool * int * int) ($45: int) ->\n        ((if - $45 + n$36 - $46.2 <= 0 && $46.0 then false else $46.0), (if - $45 + n$36 - $46.2 <= 0 && $46.0 then $45 else $46.1), $45 + $46.2)\n    ) (true, 0, 0) (range 100000)).1\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n) {\n  bool x = true;\n  int64_t x2 = 0ll;\n  int64_t x3 = 0ll;\n  for (int32_t i = 0; i < 100000ll; ++i) {\n    bool x4 = -i + n - x3 <= 0ll and x ? false : x;\n    int64_t x5 = -i + n - x3 <= 0ll and x ? i : x2;\n    int64_t x6 = i + x3;\n    x = x4;\n    x2 = x5;\n    x3 = x6;\n  }\n  return x2;\n}\nint main() {\n  int64_t x7 = -1ll;\n  std::cin >> x7;\n  auto x8 = solve(x7);\n  std::cout << x8 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/abc207_b.py", "python": "# https://atcoder.jp/contests/abc207/tasks/abc207_b\n\n# from typing import *\n\ndef solve(a: int, b: int, c: int, d: int) -> int:\n    ans = -1\n    if d*c - b > 0:\n        ans = (a + d*c - b - 1) // (d*c - b) # ans = a /^ (d*c - b)\n    return ans\n\ndef main() -> None:\n    a, b, c, d = map(int, input().split())\n    ans = solve(a, b, c, d)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(a: int, b: int, c: int, d: int) -> int:\n    ans: $0 = - 1\n    if d * c - b > 0:\n        ans: $2 = a + d * c - b - 1 // d * c - b\n    return ans\ndef main() -> None:\n    a, b, c, d: $3 = map(int, input().split())\n    ans: $4 = solve(a, b, c, d)\n    print(ans)\n", "core": "fun (a$37: int) (b$38: int) (c$39: int) (d$40: int) ->\n    if b$38 - c$39 * d$40 < 0 then (a$37 - b$38 + c$39 * d$40 - 1) / (- b$38 + c$39 * d$40) else -1\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t a, int64_t b, int64_t c, int64_t d) {\n  return b - c * d < 0ll ? jikka::floordiv(a - b + c * d - 1ll, -b + c * d)\n                         : -1ll;\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  int64_t x4 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  std::cin >> x3;\n  std::cin >> x4;\n  auto x5 = solve(x, x2, x3, x4);\n  std::cout << x5 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/abc208_b.py", "python": "# https://atcoder.jp/contests/abc208/tasks/abc208_b\n\n# from typing import *\n\ndef solve(p: int) -> int:\n    e = 1\n    cs = []\n    ans = 0\n    for i in range(10):\n        e *= i+1\n        cs.append(e)\n    for c in reversed(cs):\n        ans += p//c\n        p -= p//c * c\n    return ans\n\ndef main() -> None:\n    p = int(input())\n    ans = solve(p)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(p: int) -> int:\n    e: $0 = 1\n    cs: $1 = []\n    ans: $3 = 0\n    for i in range(10):\n        e *= i + 1\n        cs.append(e)\n    for c in reversed(cs):\n        ans += p // c\n        p -= p // c * c\n    return ans\ndef main() -> None:\n    p: $4 = int(input())\n    ans: $5 = solve(p)\n    print(ans)\n", "core": "fun (p$45: int) ->\n    (foldl (fun ($66: int * int) ($65: int) ->\n        (- ($65 * ($66.0 / $65)) + $66.0, $66.1 + $66.0 / $65)\n    ) (p$45, 0) (reverse (foldl (fun ($56: int list * int) ($55: int) ->\n        (snoc $56.0 ($55 * $56.1 + $56.1), $55 * $56.1 + $56.1)\n    ) (nil, 1) (range 10)).0)).1\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t p) {\n  std::vector<int64_t> x;\n  int64_t x2 = 1ll;\n  for (int32_t i = 0; i < 10ll; ++i) {\n    x.push_back(i * x2 + x2);\n    int64_t x3 = i * x2 + x2;\n    x2 = x3;\n  }\n  std::reverse(x.begin(), x.end());\n  int64_t x4 = 0ll;\n  for (int64_t x5 : x) {\n    int64_t x6 = -(x5 * jikka::floordiv(p, x5)) + p;\n    int64_t x7 = x4 + jikka::floordiv(p, x5);\n    p = x6;\n    x4 = x7;\n  }\n  return x4;\n}\nint main() {\n  int64_t x8 = -1ll;\n  std::cin >> x8;\n  auto x9 = solve(x8);\n  std::cout << x9 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_a.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_a\nfrom typing import *\n\ndef solve(n: int, h: List[int]) -> int:\n    assert 2 <= n <= 10 ** 5\n    assert len(h) == n\n    assert all(1 <= h_i <= 10 ** 4 for h_i in h)\n\n    dp = [-1 for _ in range(n)]\n    dp[0] = 0\n    dp[1] = abs(h[1] - h[0])\n    for i in range(2, n):\n        dp[i] = min(dp[i - 1] + abs(h[i] - h[i - 1]), dp[i - 2] + abs(h[i] - h[i - 2]))\n    return dp[n - 1]\n\ndef main() -> None:\n    n = int(input())\n    h = list(map(int, input().split()))\n    assert len(h) == n\n    ans = solve(n, h)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, h: List[int]) -> int:\n    assert 2 <= n and n <= 10 ** 5\n    assert len(h) == n\n    assert all(1 <= h_i and h_i <= 10 ** 4 for h_i in h)\n    dp: $5 = [- 1 for _ in range(n)]\n    dp[0]: $6 = 0\n    dp[1]: $7 = abs(h[1] - h[0])\n    for i in range(2, n):\n        dp[i]: $8 = min(dp[i - 1] + abs(h[i] - h[i - 1]), dp[i - 2] + abs(h[i] - h[i - 2]))\n    return dp[n - 1]\ndef main() -> None:\n    n: $9 = int(input())\n    h: $10 = list(map(int, input().split()))\n    assert len(h) == n\n    ans: $12 = solve(n, h)\n    print(ans)\n", "core": "fun (n$91: int) (h$92: int list) ->\n    assert - n$91 + 2 <= 0 && n$91 - 100000 <= 0 in\n    assert - n$91 + len h$92 == 0 in\n    assert all (map (fun ($97: int) ->\n        - $97 + 1 <= 0 && $97 - 10000 <= 0\n    ) h$92) in\n    if n$91 - 1 == 0 then 0 else (scanl (fun ($266: int * int) ($265: int) ->\n        ($266.1, min (abs (- h$92[$265 + 1] + h$92[$265 + 2]) + $266.1) (abs (- h$92[$265] + h$92[$265 + 2]) + $266.0))\n    ) (0, abs (- h$92[0] + h$92[1])) (range (n$91 - 2)))[n$91 - 2].1\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> h) {\n  assert(-n + 2ll <= 0ll and n - 100000ll <= 0ll);\n  assert(-n + int64_t(h.size()) == 0ll);\n  for (int64_t x : h) {\n    assert(-x + 1ll <= 0ll and x - 10000ll <= 0ll);\n  }\n  int64_t x2;\n  if (n - 1ll == 0ll) {\n    x2 = 0ll;\n  } else {\n    std::vector<std::array<int64_t, 2>> x3(n - 2ll + 1);\n    x3[0] = std::array<int64_t, 2>{0ll, std::abs(-h[0ll] + h[1ll])};\n    for (int32_t i = 0; i < int32_t(n - 2ll); ++i) {\n      x3[i + 1] = std::array<int64_t, 2>{\n          x3[i][1],\n          std::min<int64_t>(std::abs(-h[i + 1ll] + h[i + 2ll]) + x3[i][1],\n                            std::abs(-h[i] + h[i + 2ll]) + x3[i][0])};\n    }\n    x2 = x3[n - 2ll][1];\n  }\n  return x2;\n}\nint main() {\n  int64_t x4 = -1ll;\n  std::cin >> x4;\n  std::vector<int64_t> x5(x4, -1ll);\n  for (int32_t i2 = 0; i2 < x4; ++i2) {\n    std::cin >> x5[i2];\n  }\n  auto x6 = solve(x4, x5);\n  std::cout << x6 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_b.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_b\nfrom typing import *\n\nINF = 10 ** 18\n\ndef solve(n: int, k: int, h: List[int]) -> int:\n    assert 2 <= n <= 10 ** 5\n    assert 1 <= k <= 100\n    assert len(h) == n\n    assert all(1 <= h_i <= 10 ** 4 for h_i in h)\n\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(max(0, i - k), i):\n            dp[i] = min(dp[i], dp[j] + abs(h[i] - h[j]))\n    return dp[n - 1]\n\ndef main() -> None:\n    n, k = map(int, input().split())\n    h = list(map(int, input().split()))\n    assert len(h) == n\n    ans = solve(n, k, h)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(n: int, k: int, h: List[int]) -> int:\n    assert 2 <= n and n <= 10 ** 5\n    assert 1 <= k and k <= 100\n    assert len(h) == n\n    assert all(1 <= h_i and h_i <= 10 ** 4 for h_i in h)\n    dp: $8 = [INF for _ in range(n)]\n    dp[0]: $9 = 0\n    for i in range(1, n):\n        for j in range(max(0, i - k), i):\n            dp[i]: $10 = min(dp[i], dp[j] + abs(h[i] - h[j]))\n    return dp[n - 1]\ndef main() -> None:\n    n, k: $11 = map(int, input().split())\n    h: $12 = list(map(int, input().split()))\n    assert len(h) == n\n    ans: $14 = solve(n, k, h)\n    print(ans)\n", "core": "fun (n$96: int) (k$97: int) (h$98: int list) ->\n    assert - n$96 + 2 <= 0 && n$96 - 100000 <= 0 in\n    assert - k$97 + 1 <= 0 && k$97 - 100 <= 0 in\n    assert - n$96 + len h$98 == 0 in\n    assert all (map (fun ($104: int) ->\n        - $104 + 1 <= 0 && $104 - 10000 <= 0\n    ) h$98) in\n    (foldl (fun ($279: int list) ($280: int) ->\n        foldl (fun ($276: int list) ($277: int) ->\n            $276[$280 + 1 <- min $276[$280 + 1] (abs (- h$98[$277 + max 0 ($280 - k$97 + 1)] + h$98[$280 + 1]) + $276[$277 + max 0 ($280 - k$97 + 1)])]\n        ) $279 (range ($280 - max 0 ($280 - k$97 + 1) + 1))\n    ) (replicate n$96 1000000000000000000)[0 <- 0] (range (n$96 - 1)))[n$96 - 1]\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t k, std::vector<int64_t> h) {\n  assert(-n + 2ll <= 0ll and n - 100000ll <= 0ll);\n  assert(-k + 1ll <= 0ll and k - 100ll <= 0ll);\n  assert(-n + int64_t(h.size()) == 0ll);\n  for (int64_t x : h) {\n    assert(-x + 1ll <= 0ll and x - 10000ll <= 0ll);\n  }\n  std::vector<int64_t> mapped(n, 1000000000000000000ll);\n  mapped[0ll] = 0ll;\n  for (int32_t i = 0; i < n - 1ll; ++i) {\n    for (int32_t i2 = 0; i2 < i - std::max<int64_t>(0ll, i - k + 1ll) + 1ll;\n         ++i2) {\n      mapped[i + 1ll] = std::min<int64_t>(\n          mapped[i + 1ll],\n          std::abs(-h[i2 + std::max<int64_t>(0ll, i - k + 1ll)] + h[i + 1ll]) +\n              mapped[i2 + std::max<int64_t>(0ll, i - k + 1ll)]);\n    }\n  }\n  return mapped[n - 1ll];\n}\nint main() {\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  std::cin >> x2;\n  std::vector<int64_t> x4(x2, -1ll);\n  std::cin >> x3;\n  for (int32_t i3 = 0; i3 < x2; ++i3) {\n    std::cin >> x4[i3];\n  }\n  auto x5 = solve(x2, x3, x4);\n  std::cout << x5 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_c.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_c\nfrom typing import *\n\ndef solve(n: int, a: List[int], b: List[int], c: List[int]) -> int:\n    assert 1 <= n <= 10 ** 5\n    assert len(a) == n\n    assert len(b) == n\n    assert len(c) == n\n    assert all(1 <= a_i <= 10 ** 4 for a_i in a)\n    assert all(1 <= b_i <= 10 ** 4 for b_i in b)\n    assert all(1 <= c_i <= 10 ** 4 for c_i in c)\n\n    dp_a = [-1 for _ in range(n + 1)]\n    dp_b = [-1 for _ in range(n + 1)]\n    dp_c = [-1 for _ in range(n + 1)]\n    dp_a[0] = 0\n    dp_b[0] = 0\n    dp_c[0] = 0\n    for i in range(n):\n        dp_a[i + 1] = a[i] + max(dp_b[i], dp_c[i])\n        dp_b[i + 1] = b[i] + max(dp_c[i], dp_a[i])\n        dp_c[i + 1] = c[i] + max(dp_a[i], dp_b[i])\n    return max([dp_a[n], dp_b[n], dp_c[n]])\n\ndef main() -> None:\n    n = int(input())\n    a = list(range(n))\n    b = list(range(n))\n    c = list(range(n))\n    for i in range(n):\n        a[i], b[i], c[i] = map(int, input().split())\n    ans = solve(n, a, b, c)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, a: List[int], b: List[int], c: List[int]) -> int:\n    assert 1 <= n and n <= 10 ** 5\n    assert len(a) == n\n    assert len(b) == n\n    assert len(c) == n\n    assert all(1 <= a_i and a_i <= 10 ** 4 for a_i in a)\n    assert all(1 <= b_i and b_i <= 10 ** 4 for b_i in b)\n    assert all(1 <= c_i and c_i <= 10 ** 4 for c_i in c)\n    dp_a: $11 = [- 1 for _ in range(n + 1)]\n    dp_b: $12 = [- 1 for _ in range(n + 1)]\n    dp_c: $13 = [- 1 for _ in range(n + 1)]\n    dp_a[0]: $14 = 0\n    dp_b[0]: $15 = 0\n    dp_c[0]: $16 = 0\n    for i in range(n):\n        dp_a[i + 1]: $17 = a[i] + max(dp_b[i], dp_c[i])\n        dp_b[i + 1]: $18 = b[i] + max(dp_c[i], dp_a[i])\n        dp_c[i + 1]: $19 = c[i] + max(dp_a[i], dp_b[i])\n    return max([dp_a[n], dp_b[n], dp_c[n]])\ndef main() -> None:\n    n: $21 = int(input())\n    a: $22 = list(range(n))\n    b: $23 = list(range(n))\n    c: $24 = list(range(n))\n    for i in range(n):\n        a[i], b[i], c[i]: $25 = map(int, input().split())\n    ans: $26 = solve(n, a, b, c)\n    print(ans)\n", "core": "fun (n$172: int) (a$173: int list) (b$174: int list) (c$175: int list) ->\n    assert - n$172 + 1 <= 0 && n$172 - 100000 <= 0 in\n    assert - n$172 + len a$173 == 0 in\n    assert - n$172 + len b$174 == 0 in\n    assert - n$172 + len c$175 == 0 in\n    assert all (map (fun ($186: int) ->\n        - $186 + 1 <= 0 && $186 - 10000 <= 0\n    ) a$173) in\n    assert all (map (fun ($190: int) ->\n        - $190 + 1 <= 0 && $190 - 10000 <= 0\n    ) b$174) in\n    assert all (map (fun ($194: int) ->\n        - $194 + 1 <= 0 && $194 - 10000 <= 0\n    ) c$175) in\n    let $262: int list * int list * int list = foldl (fun ($221: int list * int list * int list) ($220: int) ->\n        let dp_a$259: int list = $221.2[$220 + 1 <- max $221.1[$220] $221.0[$220] + a$173[$220]]\n        in let dp_b$260: int list = $221.1[$220 + 1 <- max $221.0[$220] dp_a$259[$220] + b$174[$220]]\n        in ($221.0[$220 + 1 <- max dp_a$259[$220] dp_b$260[$220] + c$175[$220]], dp_b$260, dp_a$259)\n    ) ((replicate (n$172 + 1) -1)[0 <- 0], (replicate (n$172 + 1) -1)[0 <- 0], (replicate (n$172 + 1) -1)[0 <- 0]) (range n$172)\n    in max $262.2[n$172] (max $262.1[n$172] (maximum (cons $262.0[n$172] nil)))\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> a, std::vector<int64_t> b,\n              std::vector<int64_t> c) {\n  assert(-n + 1ll <= 0ll and n - 100000ll <= 0ll);\n  assert(-n + int64_t(a.size()) == 0ll);\n  assert(-n + int64_t(b.size()) == 0ll);\n  assert(-n + int64_t(c.size()) == 0ll);\n  for (int64_t x : a) {\n    assert(-x + 1ll <= 0ll and x - 10000ll <= 0ll);\n  }\n  for (int64_t x2 : b) {\n    assert(-x2 + 1ll <= 0ll and x2 - 10000ll <= 0ll);\n  }\n  for (int64_t x3 : c) {\n    assert(-x3 + 1ll <= 0ll and x3 - 10000ll <= 0ll);\n  }\n  std::vector<int64_t> mapped(n + 1ll, -1ll);\n  std::vector<int64_t> mapped2(n + 1ll, -1ll);\n  std::vector<int64_t> mapped3(n + 1ll, -1ll);\n  mapped[0ll] = 0ll;\n  mapped2[0ll] = 0ll;\n  mapped3[0ll] = 0ll;\n  for (int32_t i = 0; i < n; ++i) {\n    mapped3[i + 1ll] = std::max<int64_t>(mapped2[i], mapped[i]) + a[i];\n    mapped2[i + 1ll] = std::max<int64_t>(mapped[i], mapped3[i]) + b[i];\n    mapped[i + 1ll] = std::max<int64_t>(mapped3[i], mapped2[i]) + c[i];\n  }\n  std::vector<int64_t> x4;\n  x4.push_back(mapped[n]);\n  x4.insert(x4.end(), std::vector<int64_t>().begin(),\n            std::vector<int64_t>().end());\n  int64_t max = *std::max_element(x4.begin(), x4.end());\n  return std::max<int64_t>(mapped3[n], std::max<int64_t>(mapped2[n], max));\n}\nint main() {\n  int64_t x5 = -1ll;\n  std::cin >> x5;\n  std::vector<int64_t> x6(x5, -1ll);\n  std::vector<int64_t> x7(x5, -1ll);\n  std::vector<int64_t> x8(x5, -1ll);\n  for (int32_t i2 = 0; i2 < x5; ++i2) {\n    std::cin >> x6[i2];\n    std::cin >> x7[i2];\n    std::cin >> x8[i2];\n  }\n  auto x9 = solve(x5, x6, x7, x8);\n  std::cout << x9 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_min_mult.py", "python": "# https://judge.kimiyuki.net/problem/dp-min-mult\nfrom typing import *\n\nINF = 10 ** 18\n\ndef solve(n: int, a: List[int], b: List[int]) -> int:\n    n = len(a)\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + a[j] * b[i])\n    return dp[n - 1]\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    b = list(map(int, input().split()))\n    assert len(b) == n\n    ans = solve(n, a, b)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(n: int, a: List[int], b: List[int]) -> int:\n    n: $1 = len(a)\n    dp: $2 = [INF for _ in range(n)]\n    dp[0]: $3 = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i]: $4 = min(dp[i], dp[j] + a[j] * b[i])\n    return dp[n - 1]\ndef main() -> None:\n    n: $5 = int(input())\n    a: $6 = list(map(int, input().split()))\n    assert len(a) == n\n    b: $8 = list(map(int, input().split()))\n    assert len(b) == n\n    ans: $10 = solve(n, a, b)\n    print(ans)\n", "core": "const (fun (a$83: int list) (b$84: int list) ->\n    (foldl (fun ($216: convex_hull_trick * int list) ($212: int) ->\n        let $218: int list = snoc $216.1 (cht_getmin $216.0 b$84[$212 + 1])\n        in (cht_insert $216.0 a$83[$212 + 1] $218[$212 + 1], $218)\n    ) (let $214: int list = snoc nil 0\n    in (foldl (fun ($213: convex_hull_trick) ($215: int) ->\n        cht_insert $213 a$83[$215] $214[$215]\n    ) cht_init (range 1), $214)) (range (len a$83 - 1))).1[len a$83 - 1]\n)\n", "cxx": "#include \"jikka/convex_hull_trick.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> a, std::vector<int64_t> b) {\n  std::vector<int64_t> x;\n  x.push_back(0ll);\n  jikka::convex_hull_trick x2;\n  for (int32_t i = 0; i < 1ll; ++i) {\n    x2.add_line(a[i], x[i]);\n  }\n  for (int32_t i2 = 0; i2 < int64_t(a.size()) - 1ll; ++i2) {\n    x.push_back(x2.get_min(b[i2 + 1ll]));\n    x2.add_line(a[i2 + 1ll], x[i2 + 1ll]);\n  }\n  return x[int64_t(a.size()) - 1ll];\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  std::vector<int64_t> x4(x3, -1ll);\n  std::vector<int64_t> x5(x3, -1ll);\n  for (int32_t i3 = 0; i3 < x3; ++i3) {\n    std::cin >> x4[i3];\n  }\n  for (int32_t i4 = 0; i4 < x3; ++i4) {\n    std::cin >> x5[i4];\n  }\n  auto x6 = solve(x3, x4, x5);\n  std::cout << x6 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_min_square_kubaru.py", "python": "# https://judge.kimiyuki.net/problem/dp-min-square\n\nINF = 10 ** 18\n\ndef solve(a: List[int]) -> int:\n    n = len(a)\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for j in range(n):\n        for i in range(j + 1, n):\n            dp[i] = min(dp[i], dp[j] + (a[i] - a[j]) ** 2)\n    return dp[n - 1]\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(a: List[int]) -> int:\n    n: $1 = len(a)\n    dp: $2 = [INF for _ in range(n)]\n    dp[0]: $3 = 0\n    for j in range(n):\n        for i in range(j + 1, n):\n            dp[i]: $4 = min(dp[i], dp[j] + a[i] - a[j] ** 2)\n    return dp[n - 1]\n", "core": "fun (a$55: int list) ->\n    (foldl (fun ($199: convex_hull_trick * int list) ($195: int) ->\n        let $201: int list = snoc $199.1 (min (- (a$55[$195 + 1] * a$55[$195 + 1]) + (if $195 + 1 == 0 then 0 else 1000000000000000000)) (cht_getmin $199.0 (a$55[$195 + 1] * -2)) + a$55[$195 + 1] * a$55[$195 + 1])\n        in (cht_insert $199.0 a$55[$195 + 1] ($201[$195 + 1] + a$55[$195 + 1] * a$55[$195 + 1]), $201)\n    ) (let $197: int list = snoc nil 0\n    in (foldl (fun ($196: convex_hull_trick) ($198: int) ->\n        cht_insert $196 a$55[$198] ($197[$198] + a$55[$198] * a$55[$198])\n    ) cht_init (range 1), $197)) (range (len a$55 - 1))).1[len a$55 - 1]\n", "cxx": "#include \"jikka/convex_hull_trick.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::vector<int64_t> x;\n  x.push_back(0ll);\n  jikka::convex_hull_trick x2;\n  for (int32_t i = 0; i < 1ll; ++i) {\n    x2.add_line(a[i], x[i] + a[i] * a[i]);\n  }\n  for (int32_t i2 = 0; i2 < int64_t(a.size()) - 1ll; ++i2) {\n    x.push_back(\n        std::min<int64_t>(-(a[i2 + 1ll] * a[i2 + 1ll]) +\n                              (i2 + 1ll == 0ll ? 0ll : 1000000000000000000ll),\n                          x2.get_min(a[i2 + 1ll] * -2ll)) +\n        a[i2 + 1ll] * a[i2 + 1ll]);\n    x2.add_line(a[i2 + 1ll], x[i2 + 1ll] + a[i2 + 1ll] * a[i2 + 1ll]);\n  }\n  return x[int64_t(a.size()) - 1ll];\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  std::vector<int64_t> x4(x3, -1ll);\n  for (int32_t i3 = 0; i3 < x3; ++i3) {\n    std::cin >> x4[i3];\n  }\n  auto x5 = solve(x4);\n  std::cout << x5 << ' ';\n}\n"}, {"path": "examples/dp_min_square_morau.py", "python": "# https://judge.kimiyuki.net/problem/dp-min-square\n\nINF = 10 ** 18\n\ndef solve(a: List[int]) -> int:\n    n = len(a)\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + (a[i] - a[j]) ** 2)\n    return dp[n - 1]\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(a: List[int]) -> int:\n    n: $1 = len(a)\n    dp: $2 = [INF for _ in range(n)]\n    dp[0]: $3 = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i]: $4 = min(dp[i], dp[j] + a[i] - a[j] ** 2)\n    return dp[n - 1]\n", "core": "fun (a$54: int list) ->\n    (foldl (fun ($192: convex_hull_trick * int list) ($188: int) ->\n        let $194: int list = snoc $192.1 (a$54[$188 + 1] * a$54[$188 + 1] + cht_getmin $192.0 (a$54[$188 + 1] * -2))\n        in (cht_insert $192.0 a$54[$188 + 1] ($194[$188 + 1] + a$54[$188 + 1] * a$54[$188 + 1]), $194)\n    ) (let $190: int list = snoc nil 0\n    in (foldl (fun ($189: convex_hull_trick) ($191: int) ->\n        cht_insert $189 a$54[$191] ($190[$191] + a$54[$191] * a$54[$191])\n    ) cht_init (range 1), $190)) (range (len a$54 - 1))).1[len a$54 - 1]\n", "cxx": "#include \"jikka/convex_hull_trick.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::vector<int64_t> x;\n  x.push_back(0ll);\n  jikka::convex_hull_trick x2;\n  for (int32_t i = 0; i < 1ll; ++i) {\n    x2.add_line(a[i], x[i] + a[i] * a[i]);\n  }\n  for (int32_t i2 = 0; i2 < int64_t(a.size()) - 1ll; ++i2) {\n    x.push_back(a[i2 + 1ll] * a[i2 + 1ll] + x2.get_min(a[i2 + 1ll] * -2ll));\n    x2.add_line(a[i2 + 1ll], x[i2 + 1ll] + a[i2 + 1ll] * a[i2 + 1ll]);\n  }\n  return x[int64_t(a.size()) - 1ll];\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  std::vector<int64_t> x4(x3, -1ll);\n  for (int32_t i3 = 0; i3 < x3; ++i3) {\n    std::cin >> x4[i3];\n  }\n  auto x5 = solve(x4);\n  std::cout << x5 << ' ';\n}\n"}, {"path": "examples/dp_q.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_q\nfrom typing import *\n\ndef solve(n: int, h: List[int], a: List[int]) -> int:\n    assert 1 <= n <= 2 * 10 ** 5\n    assert len(h) == n\n    assert all(1 <= h_i <= n for h_i in h)\n    assert len(a) == n\n    assert all(1 <= a_i <= 10 ** 9 for a_i in a)\n\n    dp = [0 for _ in range(n)]\n    for i in range(n):\n        b = 0\n        for j in range(h[i]):\n            b = max(b, dp[j])\n        dp[h[i] - 1] = b + a[i]\n    return max(dp)\n\ndef main() -> None:\n    n = int(input())\n    h = list(map(int, input().split()))\n    assert len(h) == n\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(n, h, a)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, h: List[int], a: List[int]) -> int:\n    assert 1 <= n and n <= 2 * 10 ** 5\n    assert len(h) == n\n    assert all(1 <= h_i and h_i <= n for h_i in h)\n    assert len(a) == n\n    assert all(1 <= a_i and a_i <= 10 ** 9 for a_i in a)\n    dp: $8 = [0 for _ in range(n)]\n    for i in range(n):\n        b: $9 = 0\n        for j in range(h[i]):\n            b: $10 = max(b, dp[j])\n        dp[h[i] - 1]: $11 = b + a[i]\n    return max(dp)\ndef main() -> None:\n    n: $12 = int(input())\n    h: $13 = list(map(int, input().split()))\n    assert len(h) == n\n    a: $15 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $17 = solve(n, h, a)\n    print(ans)\n", "core": "fun (n$109: int) (h$110: int list) (a$111: int list) ->\n    assert - n$109 + 1 <= 0 && n$109 - 200000 <= 0 in\n    assert - n$109 + len h$110 == 0 in\n    assert all (map (fun ($119: int) ->\n        - $119 + 1 <= 0 && $119 - n$109 <= 0\n    ) h$110) in\n    assert - n$109 + len a$111 == 0 in\n    assert all (map (fun ($123: int) ->\n        - $123 + 1 <= 0 && $123 - 1000000000 <= 0\n    ) a$111) in\n    maximum (let $285: int list = replicate n$109 0\n    in (foldl (fun ($283: int list * segment_tree<int_max>) ($133: int) ->\n        let $284: int = max 0 (segtree_getrange $283.1 0 h$110[$133]) + a$111[$133]\n        in ($283.0[h$110[$133] - 1 <- $284], segtree_setpoint $283.1 (h$110[$133] - 1) $284)\n    ) ($285, segtree_initlist $285) (range n$109)).0)\n", "cxx": "#include \"jikka/segment_tree.hpp\"\n#include <algorithm>\n#include <array>\n#include <atcoder/segtree>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> h, std::vector<int64_t> a) {\n  assert(-n + 1ll <= 0ll and n - 200000ll <= 0ll);\n  assert(-n + int64_t(h.size()) == 0ll);\n  for (int64_t x : h) {\n    assert(-x + 1ll <= 0ll and x - n <= 0ll);\n  }\n  assert(-n + int64_t(a.size()) == 0ll);\n  for (int64_t x2 : a) {\n    assert(-x2 + 1ll <= 0ll and x2 - 1000000000ll <= 0ll);\n  }\n  std::vector<int64_t> mapped(n, 0ll);\n  std::vector<int64_t> x3 = mapped;\n  atcoder::segtree<int64_t, jikka::max_int64_t, jikka::const_int64_min> x4(\n      mapped);\n  for (int32_t i = 0; i < n; ++i) {\n    int64_t x5 = std::max<int64_t>(0ll, x4.prod(0ll, h[i])) + a[i];\n    x3[h[i] - 1ll] = x5;\n    x4.set(h[i] - 1ll, x5);\n  }\n  int64_t max = *std::max_element(x3.begin(), x3.end());\n  return max;\n}\nint main() {\n  int64_t x6 = -1ll;\n  std::cin >> x6;\n  std::vector<int64_t> x7(x6, -1ll);\n  std::vector<int64_t> x8(x6, -1ll);\n  for (int32_t i2 = 0; i2 < x6; ++i2) {\n    std::cin >> x7[i2];\n  }\n  for (int32_t i3 = 0; i3 < x6; ++i3) {\n    std::cin >> x8[i3];\n  }\n  auto x9 = solve(x6, x7, x8);\n  std::cout << x9 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_z-kubaru.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_z\nfrom typing import *\n\nINF = 10 ** 18\n\ndef solve(n: int, c: int, h: List[int]) -> int:\n    assert 2 <= n <= 2 * 10 ** 5\n    assert 1 <= c <= 10 ** 12\n    assert len(h) == n\n    assert all(1 <= h_i <= 10 ** 6 for h_i in h)\n\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j] = min(dp[j], dp[i] + (h[i] - h[j]) ** 2 + c)\n    return dp[n - 1]\n\ndef main() -> None:\n    n, c = map(int, input().split())\n    h = list(map(int, input().split()))\n    assert len(h) == n\n    ans = solve(n, c, h)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(n: int, c: int, h: List[int]) -> int:\n    assert 2 <= n and n <= 2 * 10 ** 5\n    assert 1 <= c and c <= 10 ** 12\n    assert len(h) == n\n    assert all(1 <= h_i and h_i <= 10 ** 6 for h_i in h)\n    dp: $8 = [INF for _ in range(n)]\n    dp[0]: $9 = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dp[j]: $10 = min(dp[j], dp[i] + h[i] - h[j] ** 2 + c)\n    return dp[n - 1]\ndef main() -> None:\n    n, c: $11 = map(int, input().split())\n    h: $12 = list(map(int, input().split()))\n    assert len(h) == n\n    ans: $14 = solve(n, c, h)\n    print(ans)\n", "core": "fun (n$93: int) (c$94: int) (h$95: int list) ->\n    assert - n$93 + 2 <= 0 && n$93 - 200000 <= 0 in\n    assert - c$94 + 1 <= 0 && c$94 - 1000000000000 <= 0 in\n    assert - n$93 + len h$95 == 0 in\n    assert all (map (fun ($101: int) ->\n        - $101 + 1 <= 0 && $101 - 1000000 <= 0\n    ) h$95) in\n    (foldl (fun ($281: convex_hull_trick * int list) ($277: int) ->\n        let $283: int list = snoc $281.1 (c$94 + min (- c$94 - h$95[$277 + 1] * h$95[$277 + 1] + (if $277 + 1 == 0 then 0 else 1000000000000000000)) (cht_getmin $281.0 (h$95[$277 + 1] * -2)) + h$95[$277 + 1] * h$95[$277 + 1])\n        in (cht_insert $281.0 h$95[$277 + 1] ($283[$277 + 1] + h$95[$277 + 1] * h$95[$277 + 1]), $283)\n    ) (let $279: int list = snoc nil 0\n    in (foldl (fun ($278: convex_hull_trick) ($280: int) ->\n        cht_insert $278 h$95[$280] ($279[$280] + h$95[$280] * h$95[$280])\n    ) cht_init (range 1), $279)) (range (n$93 - 1))).1[n$93 - 1]\n", "cxx": "#include \"jikka/convex_hull_trick.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t c, std::vector<int64_t> h) {\n  assert(-n + 2ll <= 0ll and n - 200000ll <= 0ll);\n  assert(-c + 1ll <= 0ll and c - 1000000000000ll <= 0ll);\n  assert(-n + int64_t(h.size()) == 0ll);\n  for (int64_t x : h) {\n    assert(-x + 1ll <= 0ll and x - 1000000ll <= 0ll);\n  }\n  std::vector<int64_t> x2;\n  x2.push_back(0ll);\n  jikka::convex_hull_trick x3;\n  for (int32_t i = 0; i < 1ll; ++i) {\n    x3.add_line(h[i], x2[i] + h[i] * h[i]);\n  }\n  for (int32_t i2 = 0; i2 < n - 1ll; ++i2) {\n    x2.push_back(\n        c +\n        std::min<int64_t>(-c - h[i2 + 1ll] * h[i2 + 1ll] +\n                              (i2 + 1ll == 0ll ? 0ll : 1000000000000000000ll),\n                          x3.get_min(h[i2 + 1ll] * -2ll)) +\n        h[i2 + 1ll] * h[i2 + 1ll]);\n    x3.add_line(h[i2 + 1ll], x2[i2 + 1ll] + h[i2 + 1ll] * h[i2 + 1ll]);\n  }\n  return x2[n - 1ll];\n}\nint main() {\n  int64_t x4 = -1ll;\n  int64_t x5 = -1ll;\n  std::cin >> x4;\n  std::vector<int64_t> x6(x4, -1ll);\n  std::cin >> x5;\n  for (int32_t i3 = 0; i3 < x4; ++i3) {\n    std::cin >> x6[i3];\n  }\n  auto x7 = solve(x4, x5, x6);\n  std::cout << x7 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/dp_z-morau.py", "python": "# https://atcoder.jp/contests/dp/tasks/dp_z\nfrom typing import *\n\nINF = 10 ** 18\n\ndef solve(n: int, c: int, h: List[int]) -> int:\n    assert 2 <= n <= 2 * 10 ** 5\n    assert 1 <= c <= 10 ** 12\n    assert len(h) == n\n    assert all(1 <= h_i <= 10 ** 6 for h_i in h)\n\n    dp = [INF for _ in range(n)]\n    dp[0] = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i] = min(dp[i], dp[j] + (h[j] - h[i]) ** 2 + c)\n    return dp[n - 1]\n\ndef main() -> None:\n    n, c = map(int, input().split())\n    h = list(map(int, input().split()))\n    assert len(h) == n\n    ans = solve(n, c, h)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "INF: $0 = 10 ** 18\ndef solve(n: int, c: int, h: List[int]) -> int:\n    assert 2 <= n and n <= 2 * 10 ** 5\n    assert 1 <= c and c <= 10 ** 12\n    assert len(h) == n\n    assert all(1 <= h_i and h_i <= 10 ** 6 for h_i in h)\n    dp: $8 = [INF for _ in range(n)]\n    dp[0]: $9 = 0\n    for i in range(1, n):\n        for j in range(i):\n            dp[i]: $10 = min(dp[i], dp[j] + h[j] - h[i] ** 2 + c)\n    return dp[n - 1]\ndef main() -> None:\n    n, c: $11 = map(int, input().split())\n    h: $12 = list(map(int, input().split()))\n    assert len(h) == n\n    ans: $14 = solve(n, c, h)\n    print(ans)\n", "core": "fun (n$92: int) (c$93: int) (h$94: int list) ->\n    assert - n$92 + 2 <= 0 && n$92 - 200000 <= 0 in\n    assert - c$93 + 1 <= 0 && c$93 - 1000000000000 <= 0 in\n    assert - n$92 + len h$94 == 0 in\n    assert all (map (fun ($100: int) ->\n        - $100 + 1 <= 0 && $100 - 1000000 <= 0\n    ) h$94) in\n    (foldl (fun ($274: convex_hull_trick * int list) ($270: int) ->\n        let $276: int list = snoc $274.1 (c$93 + h$94[$270 + 1] * h$94[$270 + 1] + cht_getmin $274.0 (h$94[$270 + 1] * -2))\n        in (cht_insert $274.0 h$94[$270 + 1] ($276[$270 + 1] + h$94[$270 + 1] * h$94[$270 + 1]), $276)\n    ) (let $272: int list = snoc nil 0\n    in (foldl (fun ($271: convex_hull_trick) ($273: int) ->\n        cht_insert $271 h$94[$273] ($272[$273] + h$94[$273] * h$94[$273])\n    ) cht_init (range 1), $272)) (range (n$92 - 1))).1[n$92 - 1]\n", "cxx": "#include \"jikka/convex_hull_trick.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t c, std::vector<int64_t> h) {\n  assert(-n + 2ll <= 0ll and n - 200000ll <= 0ll);\n  assert(-c + 1ll <= 0ll and c - 1000000000000ll <= 0ll);\n  assert(-n + int64_t(h.size()) == 0ll);\n  for (int64_t x : h) {\n    assert(-x + 1ll <= 0ll and x - 1000000ll <= 0ll);\n  }\n  std::vector<int64_t> x2;\n  x2.push_back(0ll);\n  jikka::convex_hull_trick x3;\n  for (int32_t i = 0; i < 1ll; ++i) {\n    x3.add_line(h[i], x2[i] + h[i] * h[i]);\n  }\n  for (int32_t i2 = 0; i2 < n - 1ll; ++i2) {\n    x2.push_back(c + h[i2 + 1ll] * h[i2 + 1ll] +\n                 x3.get_min(h[i2 + 1ll] * -2ll));\n    x3.add_line(h[i2 + 1ll], x2[i2 + 1ll] + h[i2 + 1ll] * h[i2 + 1ll]);\n  }\n  return x2[n - 1ll];\n}\nint main() {\n  int64_t x4 = -1ll;\n  int64_t x5 = -1ll;\n  std::cin >> x4;\n  std::vector<int64_t> x6(x4, -1ll);\n  std::cin >> x5;\n  for (int32_t i3 = 0; i3 < x4; ++i3) {\n    std::cin >> x6[i3];\n  }\n  auto x7 = solve(x4, x5, x6);\n  std::cout << x7 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/fact.py", "python": "def solve(n: int) -> int:\n    ans = 1\n    for i in range(n):\n        ans *= i + 1\n    return ans % 998244353\n", "rpython": "def solve(n: int) -> int:\n    ans: $0 = 1\n    for i in range(n):\n        ans *= i + 1\n    return ans % 998244353\n", "core": "fun (n$14: int) ->\n    modproduct (map (fun ($57: int) ->\n        modplus ($57 % 998244353) 1 998244353\n    ) (range n$14)) 998244353\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n) {\n  std::vector<int64_t> mapped(n);\n  for (int32_t i = 0; i < int32_t(n); ++i) {\n    mapped[i] =\n        jikka::mod::plus(jikka::floormod(i, 998244353ll), 1ll, 998244353ll);\n  }\n  int64_t prod = 1ll;\n  for (int64_t x : mapped) {\n    prod = jikka::mod::mult(prod, x, 998244353ll);\n  }\n  return prod;\n}\nint main() {\n  int64_t x2 = -1ll;\n  std::cin >> x2;\n  auto x3 = solve(x2);\n  std::cout << x3 << ' ';\n}\n"}, {"path": "examples/fib.py", "python": "def f(n: int) -> int:\n    a = 0\n    b = 1\n    for _ in range(n):\n        c = a + b\n        a = b\n        b = c\n    return a\n\ndef solve(n: int) -> int:\n    return f(n) % 998244353\n", "rpython": "def f(n: int) -> int:\n    a: $0 = 0\n    b: $1 = 1\n    for _ in range(n):\n        c: $2 = a + b\n        a: $3 = b\n        b: $4 = c\n    return a\ndef solve(n: int) -> int:\n    return f(n) % 998244353\n", "core": "fun (n$38: int) ->\n    (modmatap@2@2 (modmatpow@2 ((1, 1), (1, 0)) n$38 998244353) (1, 0) 998244353).1\n", "cxx": "#include \"jikka/modulo_matrix.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n) {\n  return jikka::modmat::ap<2, 2>(jikka::modmat::pow<2>(\n                                     std::array<std::array<int64_t, 2>, 2>{\n                                         std::array<int64_t, 2>{1ll, 1ll},\n                                         std::array<int64_t, 2>{1ll, 0ll}},\n                                     n, 998244353ll),\n                                 std::array<int64_t, 2>{1ll, 0ll},\n                                 998244353ll)[1];\n}\nint main() {\n  int64_t x = -1ll;\n  std::cin >> x;\n  auto x2 = solve(x);\n  std::cout << x2 << ' ';\n}\n"}, {"path": "examples/fib_list_riantkb.py", "python": "# See https://github.com/kmyk/Jikka/issues/178\nfrom typing import *\n\n\ndef solve(n: int) -> int:\n    a = 0\n    b = 1\n    lis = []\n    for i in range(n):\n        lis.append(0)\n    for i in lis:\n        c = a + b + i\n        a = b\n        b = c\n    return a % 1000000007\n\n\ndef main():\n    n = int(input())\n    ans = solve(n)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(n: int) -> int:\n    a: $0 = 0\n    b: $1 = 1\n    lis: $2 = []\n    for i in range(n):\n        lis.append(0)\n    for i in lis:\n        c: $4 = a + b + i\n        a: $5 = b\n        b: $6 = c\n    return a % 1000000007\ndef main() -> $9:\n    n: $7 = int(input())\n    ans: $8 = solve(n)\n    print(ans)\n", "core": "fun (n$48: int) ->\n    (foldl (fun ($138: int * int) ($139: int) ->\n        (modplus (modplus ($139 % 1000000007) (vecfloormod@2 $138 1000000007).0 1000000007) (vecfloormod@2 $138 1000000007).1 1000000007, (vecfloormod@2 $138 1000000007).0)\n    ) (1, 0) (iterate n$48 (fun ($60: int list) ->\n        snoc $60 0\n    ) nil)).1\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include \"jikka/modulo_matrix.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n) {\n  std::vector<int64_t> x;\n  for (int32_t i = 0; i < int32_t(n); ++i) {\n    x.push_back(0ll);\n  }\n  int64_t x2 = 1ll;\n  int64_t x3 = 0ll;\n  for (int64_t x4 : x) {\n    int64_t x5 = jikka::mod::plus(\n        jikka::mod::plus(jikka::floormod(x4, 1000000007ll),\n                         jikka::modmat::floormod<2>(\n                             std::array<int64_t, 2>{x2, x3}, 1000000007ll)[0],\n                         1000000007ll),\n        jikka::modmat::floormod<2>(std::array<int64_t, 2>{x2, x3},\n                                   1000000007ll)[1],\n        1000000007ll);\n    int64_t x6 = jikka::modmat::floormod<2>(std::array<int64_t, 2>{x2, x3},\n                                            1000000007ll)[0];\n    x2 = x5;\n    x3 = x6;\n  }\n  return x3;\n}\nint main() {\n  int64_t x7 = -1ll;\n  std::cin >> x7;\n  auto x8 = solve(x7);\n  std::cout << x8 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/higher_order_function.py", "python": "from typing import *\n\ndef repeat(f: Callable[[int], int], k: int) -> Callable[[int], int]:\n    g = lambda x: x\n    for _ in range(k):\n        g = (lambda g: lambda x: f(g(x)))(g)\n    return g\n\ndef solve(n: int) -> int:\n    return repeat(lambda x: x + n, n)(n)\n", "rpython": "def repeat(f: Callable[[int], int], k: int) -> Callable[[int], int]:\n    g: $0 = lambda x: x\n    for _ in range(k):\n        g: $2 = lambda g: lambda x: f(g(x))(g)\n    return g\ndef solve(n: int) -> int:\n    return repeat(lambda x: x + n, n)(n)\n", "core": "fun (n$53: int) ->\n    iterate n$53 (fun ($60: int -> int) ($104: int) ->\n        n$53 + $60 $104\n    ) id n$53\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n) {\n  std::function<int64_t(int64_t)> x2 = [=](int64_t x) -> int64_t { return x; };\n  for (int32_t i = 0; i < int32_t(n); ++i) {\n    x2 = [=](int64_t b) -> int64_t { return n + x2(b); };\n  }\n  return x2(n);\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  auto x4 = solve(x3);\n  std::cout << x4 << ' ';\n}\n"}, {"path": "examples/list_literal.py", "python": "def solve(a: int, b: int, c:int) -> int:\n    return sum([a, b, c])\n", "rpython": "def solve(a: int, b: int, c: int) -> int:\n    return sum([a, b, c])\n", "core": "fun (a$11: int) (b$12: int) (c$13: int) ->\n    a$11 + b$12 + c$13\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t a, int64_t b, int64_t c) { return a + b + c; }\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  std::cin >> x3;\n  auto x4 = solve(x, x2, x3);\n  std::cout << x4 << ' ';\n}\n"}, {"path": "examples/loop_mod_uta8a.py", "python": "# See https://github.com/kmyk/Jikka/issues/173\n\ndef solve(n: int, k: int) -> int:\n    for _ in range(k):\n        n = n % 3\n    return n\n\ndef main() -> None:\n    n, k = map(int, input().split())\n    ans = solve(n, k)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, k: int) -> int:\n    for _ in range(k):\n        n: $0 = n % 3\n    return n\ndef main() -> None:\n    n, k: $1 = map(int, input().split())\n    ans: $2 = solve(n, k)\n    print(ans)\n", "core": "fun (n$22: int) (k$23: int) ->\n    if range k$23 == nil then n$22 else n$22 % 3\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/range.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, int64_t k) {\n  return jikka::range(k) == std::vector<int64_t>() ? n\n                                                   : jikka::floormod(n, 3ll);\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  auto x3 = solve(x, x2);\n  std::cout << x3 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/method_calls.py", "python": "def solve(a: int, b: int, c: int) -> int:\n    xs = [a, b, c, 1]\n    return xs.count(0) + xs.index(1)\n", "rpython": "def solve(a: int, b: int, c: int) -> int:\n    xs: $0 = [a, b, c, 1]\n    return xs.count(0) + xs.index(1)\n", "core": "fun (a$20: int) (b$21: int) (c$22: int) ->\n    let xs$23: int list = cons a$20 (cons b$21 (cons c$22 (cons 1 nil)))\n    in len (filter (fun (y: int) ->\n        y == 0\n    ) xs$23) + minimum (filter (fun (i: int) ->\n        xs$23[i] - 1 == 0\n    ) (range (len xs$23)))\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t a, int64_t b, int64_t c) {\n  std::vector<int64_t> x;\n  x.push_back(1ll);\n  x.insert(x.end(), std::vector<int64_t>().begin(),\n           std::vector<int64_t>().end());\n  std::vector<int64_t> x2;\n  x2.push_back(c);\n  x2.insert(x2.end(), x.begin(), x.end());\n  std::vector<int64_t> x3;\n  x3.push_back(b);\n  x3.insert(x3.end(), x2.begin(), x2.end());\n  std::vector<int64_t> x4;\n  x4.push_back(a);\n  x4.insert(x4.end(), x3.begin(), x3.end());\n  std::vector<int64_t> filtered_xs;\n  for (int64_t x5 : x4) {\n    if (x5 == 0ll) {\n      filtered_xs.push_back(x5);\n    }\n  }\n  std::vector<int64_t> filtered;\n  for (int32_t i = 0; i < int64_t(x4.size()); ++i) {\n    if (x4[i] - 1ll == 0ll) {\n      filtered.push_back(i);\n    }\n  }\n  int64_t min = *std::min_element(filtered.begin(), filtered.end());\n  return int64_t(filtered_xs.size()) + min;\n}\nint main() {\n  int64_t x6 = -1ll;\n  int64_t x7 = -1ll;\n  int64_t x8 = -1ll;\n  std::cin >> x6;\n  std::cin >> x7;\n  std::cin >> x8;\n  auto x9 = solve(x6, x7, x8);\n  std::cout << x9 << ' ';\n}\n"}, {"path": "examples/static_range_sum.py", "python": "# https://judge.yosupo.jp/problem/static_range_sum\n\nfrom typing import *\n\ndef solve(n: int, q: int, a: List[int], l: List[int], r: List[int]) -> List[int]:\n    ans = [-1 for _ in range(q)]\n    for i in range(q):\n        ans[i] = sum(a[l[i]:r[i]])\n    return ans\n\ndef main() -> None:\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    l = list(range(q))\n    r = list(range(q))\n    for i in range(q):\n        l[i], r[i] = map(int, input().split())\n    ans = solve(n, q, a, l, r)\n    for i in range(q):\n        print(ans[i])\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, q: int, a: List[int], l: List[int], r: List[int]) -> List[int]:\n    ans: $0 = [- 1 for _ in range(q)]\n    for i in range(q):\n        ans[i]: $1 = sum(a[l[i]:r[i]])\n    return ans\ndef main() -> None:\n    n, q: $2 = map(int, input().split())\n    a: $3 = list(map(int, input().split()))\n    assert len(a) == n\n    l: $5 = list(range(q))\n    r: $6 = list(range(q))\n    for i in range(q):\n        l[i], r[i]: $7 = map(int, input().split())\n    ans: $8 = solve(n, q, a, l, r)\n    for i in range(q):\n        print(ans[i])\n", "core": "const (fun (q$69: int) (a$70: int list) (l$71: int list) (r$72: int list) ->\n    let $143: int list = scanl (fun ($144: int) ($145: int) ->\n        $144 + $145\n    ) 0 a$70\n    in map (fun ($82: int) ->\n        - $143[l$71[$82]] + $143[r$72[$82]]\n    ) (range q$69)\n)\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nstd::vector<int64_t> solve(int64_t n, int64_t q, std::vector<int64_t> a,\n                           std::vector<int64_t> l, std::vector<int64_t> r) {\n  std::vector<int64_t> x(a.size() + 1);\n  x[0] = 0ll;\n  for (int32_t i = 0; i < int32_t(a.size()); ++i) {\n    x[i + 1] = x[i] + a[i];\n  }\n  std::vector<int64_t> mapped(q);\n  for (int32_t i2 = 0; i2 < int32_t(q); ++i2) {\n    mapped[i2] = -x[l[i2]] + x[r[i2]];\n  }\n  return mapped;\n}\nint main() {\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  std::cin >> x2;\n  std::vector<int64_t> x4(x2, -1ll);\n  std::cin >> x3;\n  std::vector<int64_t> x5(x3, -1ll);\n  std::vector<int64_t> x6(x3, -1ll);\n  for (int32_t i3 = 0; i3 < x2; ++i3) {\n    std::cin >> x4[i3];\n  }\n  for (int32_t i4 = 0; i4 < x3; ++i4) {\n    std::cin >> x5[i4];\n    std::cin >> x6[i4];\n  }\n  auto x7 = solve(x2, x3, x4, x5, x6);\n  for (int32_t i5 = 0; i5 < x3; ++i5) {\n    std::cout << x7[i5] << ' ';\n    std::cout << '\\n' << ' ';\n  }\n}\n"}, {"path": "examples/sum_ax_plus_b.py", "python": "# https://judge.kimiyuki.net/problem/sum-ax-plus-b\ndef solve(a: int, b: int, n: int) -> int:\n    y = 0\n    for x in range(n):\n        y += a * x + b\n    return y % 998244353\n", "rpython": "def solve(a: int, b: int, n: int) -> int:\n    y: $0 = 0\n    for x in range(n):\n        y += a * x + b\n    return y % 998244353\n", "core": "fun (a$20: int) (b$21: int) (n$22: int) ->\n    modplus (modplus (modmult (modmult (a$20 % 998244353) (n$22 % 998244353) 998244353) 499122176 998244353) (modmult (modmult (modmult (a$20 % 998244353) (n$22 % 998244353) 998244353) (n$22 % 998244353) 998244353) 499122177 998244353) 998244353) (modmult (b$21 % 998244353) (n$22 % 998244353) 998244353) 998244353\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t a, int64_t b, int64_t n) {\n  return jikka::mod::plus(\n      jikka::mod::plus(\n          jikka::mod::mult(jikka::mod::mult(jikka::floormod(a, 998244353ll),\n                                            jikka::floormod(n, 998244353ll),\n                                            998244353ll),\n                           499122176ll, 998244353ll),\n          jikka::mod::mult(\n              jikka::mod::mult(jikka::mod::mult(jikka::floormod(a, 998244353ll),\n                                                jikka::floormod(n, 998244353ll),\n                                                998244353ll),\n                               jikka::floormod(n, 998244353ll), 998244353ll),\n              499122177ll, 998244353ll),\n          998244353ll),\n      jikka::mod::mult(jikka::floormod(b, 998244353ll),\n                       jikka::floormod(n, 998244353ll), 998244353ll),\n      998244353ll);\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  std::cin >> x3;\n  auto x4 = solve(x, x2, x3);\n  std::cout << x4 << ' ';\n}\n"}, {"path": "examples/sum_sum_abs_one.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-abs-one\nfrom typing import *\n\ndef solve(a: List[int]) -> int:\n    ans = 0\n    for a_i in a:\n        for a_j in a:\n            ans += abs(a_i - a_j)\n    return ans\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(a)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int]) -> int:\n    ans: $0 = 0\n    for a_i in a:\n        for a_j in a:\n            ans += abs(a_i - a_j)\n    return ans\ndef main() -> None:\n    n: $1 = int(input())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $4 = solve(a)\n    print(ans)\n", "core": "fun (a$34: int list) ->\n    let a$98: int list = sort a$34\n    in - (len a$98 * (scanl (fun ($122: int) ($123: int) ->\n        $122 + $123\n    ) 0 a$98)[len a$98]) + sum (map (fun ($99: int) ->\n        $99 * a$98[$99]\n    ) (range (len a$98))) + sum (map (fun ($114: int) ->\n        $114 * a$98[$114]\n    ) (range (len a$98))) - sum (let $110: int list = scanl (fun ($111: int) ($112: int) ->\n        $111 + $112\n    ) 0 a$98\n    in map (fun ($109: int) ->\n        $110[$109]\n    ) (range (len a$98))) + sum (let $115: int list = scanl (fun ($116: int) ($117: int) ->\n        $116 + $117\n    ) 0 a$98\n    in map (fun ($107: int) ->\n        $115[len a$98] - $115[$107 + 1]\n    ) (range (len a$98))) + (scanl (fun ($124: int) ($125: int) ->\n        $124 + $125\n    ) 0 a$98)[len a$98]\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::sort(a.begin(), a.end());\n  std::vector<int64_t> x(a.size() + 1);\n  x[0] = 0ll;\n  for (int32_t i = 0; i < int32_t(a.size()); ++i) {\n    x[i + 1] = x[i] + a[i];\n  }\n  std::vector<int64_t> mapped(int64_t(a.size()));\n  for (int32_t i2 = 0; i2 < int32_t(int64_t(a.size())); ++i2) {\n    mapped[i2] = i2 * a[i2];\n  }\n  int64_t sum = std::accumulate(mapped.begin(), mapped.end(), 0ll);\n  std::vector<int64_t> mapped2(int64_t(a.size()));\n  for (int32_t i3 = 0; i3 < int32_t(int64_t(a.size())); ++i3) {\n    mapped2[i3] = i3 * a[i3];\n  }\n  int64_t sum2 = std::accumulate(mapped2.begin(), mapped2.end(), 0ll);\n  std::vector<int64_t> x2(a.size() + 1);\n  x2[0] = 0ll;\n  for (int32_t i4 = 0; i4 < int32_t(a.size()); ++i4) {\n    x2[i4 + 1] = x2[i4] + a[i4];\n  }\n  std::vector<int64_t> mapped3(int64_t(a.size()));\n  for (int32_t i5 = 0; i5 < int32_t(int64_t(a.size())); ++i5) {\n    mapped3[i5] = x2[i5];\n  }\n  int64_t sum3 = std::accumulate(mapped3.begin(), mapped3.end(), 0ll);\n  std::vector<int64_t> x3(a.size() + 1);\n  x3[0] = 0ll;\n  for (int32_t i6 = 0; i6 < int32_t(a.size()); ++i6) {\n    x3[i6 + 1] = x3[i6] + a[i6];\n  }\n  std::vector<int64_t> mapped4(int64_t(a.size()));\n  for (int32_t i7 = 0; i7 < int32_t(int64_t(a.size())); ++i7) {\n    mapped4[i7] = x3[int64_t(a.size())] - x3[i7 + 1ll];\n  }\n  int64_t sum4 = std::accumulate(mapped4.begin(), mapped4.end(), 0ll);\n  std::vector<int64_t> x4(a.size() + 1);\n  x4[0] = 0ll;\n  for (int32_t i8 = 0; i8 < int32_t(a.size()); ++i8) {\n    x4[i8 + 1] = x4[i8] + a[i8];\n  }\n  return -(int64_t(a.size()) * x[int64_t(a.size())]) + sum + sum2 - sum3 +\n         sum4 + x4[int64_t(a.size())];\n}\nint main() {\n  int64_t x5 = -1ll;\n  std::cin >> x5;\n  std::vector<int64_t> x6(x5, -1ll);\n  for (int32_t i9 = 0; i9 < x5; ++i9) {\n    std::cin >> x6[i9];\n  }\n  auto x7 = solve(x6);\n  std::cout << x7 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/sum_sum_mult.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-square\nfrom typing import *\n\n\ndef solve(a: List[int]) -> int:\n    ans = 0\n    for a_i in a:\n        for a_j in a:\n            ans += a_i * a_j\n    return ans % 998244353\n\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(a)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int]) -> int:\n    ans: $0 = 0\n    for a_i in a:\n        for a_j in a:\n            ans += a_i * a_j\n    return ans % 998244353\ndef main() -> None:\n    n: $1 = int(input())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $4 = solve(a)\n    print(ans)\n", "core": "fun (a$33: int list) ->\n    modmult (modsum (map (fun ($99: int) ->\n        $99 % 998244353\n    ) a$33) 998244353) (modsum (map (fun ($100: int) ->\n        $100 % 998244353\n    ) a$33) 998244353) 998244353\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::vector<int64_t> mapped_a(a.size());\n  for (int32_t i = 0; i < int32_t(a.size()); ++i) {\n    mapped_a[i] = jikka::floormod(a[i], 998244353ll);\n  }\n  int64_t sum = 0ll;\n  for (int64_t x : mapped_a) {\n    sum += jikka::floormod(x, 998244353ll);\n  }\n  std::vector<int64_t> mapped_a2(a.size());\n  for (int32_t i2 = 0; i2 < int32_t(a.size()); ++i2) {\n    mapped_a2[i2] = jikka::floormod(a[i2], 998244353ll);\n  }\n  int64_t sum2 = 0ll;\n  for (int64_t x2 : mapped_a2) {\n    sum2 += jikka::floormod(x2, 998244353ll);\n  }\n  return jikka::mod::mult(jikka::floormod(sum, 998244353ll),\n                          jikka::floormod(sum2, 998244353ll), 998244353ll);\n}\nint main() {\n  int64_t x3 = -1ll;\n  std::cin >> x3;\n  std::vector<int64_t> x4(x3, -1ll);\n  for (int32_t i3 = 0; i3 < x3; ++i3) {\n    std::cin >> x4[i3];\n  }\n  auto x5 = solve(x4);\n  std::cout << x5 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/sum_sum_plus_one.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-plus-one\nfrom typing import *\n\n\ndef solve(a: List[int]) -> int:\n    ans = 0\n    for a_i in a:\n        for a_j in a:\n            ans += a_i - a_j\n    return ans\n\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(a)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int]) -> int:\n    ans: $0 = 0\n    for a_i in a:\n        for a_j in a:\n            ans += a_i - a_j\n    return ans\ndef main() -> None:\n    n: $1 = int(input())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $4 = solve(a)\n    print(ans)\n", "core": "const 0\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) { return 0ll; }\nint main() {\n  int64_t x = -1ll;\n  std::cin >> x;\n  std::vector<int64_t> x2(x, -1ll);\n  for (int32_t i = 0; i < x; ++i) {\n    std::cin >> x2[i];\n  }\n  auto x3 = solve(x2);\n  std::cout << x3 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/sum_sum_plus_one_lt.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-plus-one-lt\nfrom typing import *\n\n\ndef solve(a: List[int]) -> int:\n    n = len(a)\n    ans = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += a[i] - a[j]\n    return ans\n\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(a)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int]) -> int:\n    n: $0 = len(a)\n    ans: $1 = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            ans += a[i] - a[j]\n    return ans\ndef main() -> None:\n    n: $2 = int(input())\n    a: $3 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $5 = solve(a)\n    print(ans)\n", "core": "fun (a$47: int list) ->\n    len a$47 * (scanl (fun ($136: int) ($137: int) ->\n        $136 + $137\n    ) 0 a$47)[len a$47] - sum (map (fun ($55: int) ->\n        $55 * a$47[$55]\n    ) (range (len a$47))) - sum (let $129: int list = scanl (fun ($130: int) ($131: int) ->\n        $130 + $131\n    ) 0 a$47\n    in map (fun ($128: int) ->\n        $129[len a$47] - $129[$128 + 1]\n    ) (range (len a$47))) - (scanl (fun ($138: int) ($139: int) ->\n        $138 + $139\n    ) 0 a$47)[len a$47]\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::vector<int64_t> x(a.size() + 1);\n  x[0] = 0ll;\n  for (int32_t i = 0; i < int32_t(a.size()); ++i) {\n    x[i + 1] = x[i] + a[i];\n  }\n  std::vector<int64_t> mapped(int64_t(a.size()));\n  for (int32_t i2 = 0; i2 < int32_t(int64_t(a.size())); ++i2) {\n    mapped[i2] = i2 * a[i2];\n  }\n  int64_t sum = std::accumulate(mapped.begin(), mapped.end(), 0ll);\n  std::vector<int64_t> x2(a.size() + 1);\n  x2[0] = 0ll;\n  for (int32_t i3 = 0; i3 < int32_t(a.size()); ++i3) {\n    x2[i3 + 1] = x2[i3] + a[i3];\n  }\n  std::vector<int64_t> mapped2(int64_t(a.size()));\n  for (int32_t i4 = 0; i4 < int32_t(int64_t(a.size())); ++i4) {\n    mapped2[i4] = x2[int64_t(a.size())] - x2[i4 + 1ll];\n  }\n  int64_t sum2 = std::accumulate(mapped2.begin(), mapped2.end(), 0ll);\n  std::vector<int64_t> x3(a.size() + 1);\n  x3[0] = 0ll;\n  for (int32_t i5 = 0; i5 < int32_t(a.size()); ++i5) {\n    x3[i5 + 1] = x3[i5] + a[i5];\n  }\n  return int64_t(a.size()) * x[int64_t(a.size())] - sum - sum2 -\n         x3[int64_t(a.size())];\n}\nint main() {\n  int64_t x4 = -1ll;\n  std::cin >> x4;\n  std::vector<int64_t> x5(x4, -1ll);\n  for (int32_t i6 = 0; i6 < x4; ++i6) {\n    std::cin >> x5[i6];\n  }\n  auto x6 = solve(x5);\n  std::cout << x6 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/sum_sum_plus_two.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-plus-two\nfrom typing import *\n\n\ndef solve(a: List[int], b: List[int]) -> int:\n    ans = 0\n    for a_i in a:\n        for b_j in b:\n            ans += a_i - b_j\n    return ans\n\n\ndef main() -> None:\n    n, m = map(int, input().split())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    b = list(map(int, input().split()))\n    assert len(b) == m\n    ans = solve(a, b)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int], b: List[int]) -> int:\n    ans: $0 = 0\n    for a_i in a:\n        for b_j in b:\n            ans += a_i - b_j\n    return ans\ndef main() -> None:\n    n, m: $1 = map(int, input().split())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    b: $4 = list(map(int, input().split()))\n    assert len(b) == m\n    ans: $6 = solve(a, b)\n    print(ans)\n", "core": "fun (a$47: int list) (b$48: int list) ->\n    - (len a$47 * sum b$48) + len b$48 * sum a$47\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a, std::vector<int64_t> b) {\n  int64_t sum_b = std::accumulate(b.begin(), b.end(), 0ll);\n  int64_t sum_a = std::accumulate(a.begin(), a.end(), 0ll);\n  return -(int64_t(a.size()) * sum_b) + int64_t(b.size()) * sum_a;\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  std::cin >> x;\n  std::vector<int64_t> x3(x, -1ll);\n  std::cin >> x2;\n  std::vector<int64_t> x4(x2, -1ll);\n  for (int32_t i = 0; i < x; ++i) {\n    std::cin >> x3[i];\n  }\n  for (int32_t i2 = 0; i2 < x2; ++i2) {\n    std::cin >> x4[i2];\n  }\n  auto x5 = solve(x3, x4);\n  std::cout << x5 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/sum_sum_square.py", "python": "# https://judge.kimiyuki.net/problem/sum-sum-square\nfrom typing import *\n\n\ndef solve(a: List[int]) -> int:\n    ans = 0\n    for a_i in a:\n        for a_j in a:\n            ans += (a_i - a_j) ** 2\n    return ans % 998244353\n\n\ndef main() -> None:\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    ans = solve(a)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n", "rpython": "def solve(a: List[int]) -> int:\n    ans: $0 = 0\n    for a_i in a:\n        for a_j in a:\n            ans += a_i - a_j ** 2\n    return ans % 998244353\ndef main() -> None:\n    n: $1 = int(input())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    ans: $4 = solve(a)\n    print(ans)\n", "core": "fun (a$33: int list) ->\n    modplus (modplus (modmult (len a$33 % 998244353) (modsum (map (fun ($102: int) ->\n        modmult ($102 % 998244353) ($102 % 998244353) 998244353\n    ) a$33) 998244353) 998244353) (modmult (len a$33 % 998244353) (modsum (map (fun ($100: int) ->\n        modmult ($100 % 998244353) ($100 % 998244353) 998244353\n    ) a$33) 998244353) 998244353) 998244353) (modmult (modmult (modsum (map (fun ($101: int) ->\n        $101 % 998244353\n    ) a$33) 998244353) (modsum (map (fun ($104: int) ->\n        $104 % 998244353\n    ) a$33) 998244353) 998244353) 998244351 998244353) 998244353\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(std::vector<int64_t> a) {\n  std::vector<int64_t> mapped_a(a.size());\n  for (int32_t i = 0; i < int32_t(a.size()); ++i) {\n    mapped_a[i] =\n        jikka::mod::mult(jikka::floormod(a[i], 998244353ll),\n                         jikka::floormod(a[i], 998244353ll), 998244353ll);\n  }\n  int64_t sum = 0ll;\n  for (int64_t x : mapped_a) {\n    sum += jikka::floormod(x, 998244353ll);\n  }\n  std::vector<int64_t> mapped_a2(a.size());\n  for (int32_t i2 = 0; i2 < int32_t(a.size()); ++i2) {\n    mapped_a2[i2] =\n        jikka::mod::mult(jikka::floormod(a[i2], 998244353ll),\n                         jikka::floormod(a[i2], 998244353ll), 998244353ll);\n  }\n  int64_t sum2 = 0ll;\n  for (int64_t x2 : mapped_a2) {\n    sum2 += jikka::floormod(x2, 998244353ll);\n  }\n  std::vector<int64_t> mapped_a3(a.size());\n  for (int32_t i3 = 0; i3 < int32_t(a.size()); ++i3) {\n    mapped_a3[i3] = jikka::floormod(a[i3], 998244353ll);\n  }\n  int64_t sum3 = 0ll;\n  for (int64_t x3 : mapped_a3) {\n    sum3 += jikka::floormod(x3, 998244353ll);\n  }\n  std::vector<int64_t> mapped_a4(a.size());\n  for (int32_t i4 = 0; i4 < int32_t(a.size()); ++i4) {\n    mapped_a4[i4] = jikka::floormod(a[i4], 998244353ll);\n  }\n  int64_t sum4 = 0ll;\n  for (int64_t x4 : mapped_a4) {\n    sum4 += jikka::floormod(x4, 998244353ll);\n  }\n  return jikka::mod::plus(\n      jikka::mod::plus(\n          jikka::mod::mult(jikka::floormod(int64_t(a.size()), 998244353ll),\n                           jikka::floormod(sum, 998244353ll), 998244353ll),\n          jikka::mod::mult(jikka::floormod(int64_t(a.size()), 998244353ll),\n                           jikka::floormod(sum2, 998244353ll), 998244353ll),\n          998244353ll),\n      jikka::mod::mult(jikka::mod::mult(jikka::floormod(sum3, 998244353ll),\n                                        jikka::floormod(sum4, 998244353ll),\n                                        998244353ll),\n                       998244351ll, 998244353ll),\n      998244353ll);\n}\nint main() {\n  int64_t x5 = -1ll;\n  std::cin >> x5;\n  std::vector<int64_t> x6(x5, -1ll);\n  for (int32_t i5 = 0; i5 < x5; ++i5) {\n    std::cin >> x6[i5];\n  }\n  auto x7 = solve(x6);\n  std::cout << x7 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/wip/tle/abc127_e.py", "python": "# https://atcoder.jp/contests/abc127/tasks/abc127_e\n\nMOD: int = 10 ** 9 + 7\n\ndef solve(h: int, w: int, k: int) -> int:\n    ans = 0\n    for y1 in range(h):\n        for x1 in range(w):\n            for y2 in range(h):\n                for x2 in range(w):\n                    if (y1, x1) < (y2, x2):\n                        ans += jikka.choose(h * w - 2, k - 2) * (abs(y2 - y1) + abs(x2 - x1))\n    return ans % MOD\n\ndef main() -> None:\n    n, m, k = map(int, input().split())\n    ans = solve(n, m, k)\n    print(ans)\n\nif __name__ == '__main__':\n    main()\n", "rpython": "MOD: int = 10 ** 9 + 7\ndef solve(h: int, w: int, k: int) -> int:\n    ans: $0 = 0\n    for y1 in range(h):\n        for x1 in range(w):\n            for y2 in range(h):\n                for x2 in range(w):\n                    if (y1, x1) < (y2, x2):\n                        ans += jikka.choose(h * w - 2, k - 2) * abs(y2 - y1) + abs(x2 - x1)\n    return ans % MOD\ndef main() -> None:\n    n, m, k: $2 = map(int, input().split())\n    ans: $3 = solve(n, m, k)\n    print(ans)\n", "core": "fun (h$58: int) (w$59: int) (k$60: int) ->\n    foldl (fun ($227: int) ($228: int) ->\n        (vecfloormod@1 (foldl (fun ($74: int) ($73: int) ->\n            foldl (fun ($79: int) ($78: int) ->\n                foldl (fun ($84: int) ($83: int) ->\n                    if ($228, $73) < ($78, $83) then $84 + abs (- $73 + $83) * choose (h$58 * w$59 - 2) (k$60 - 2) + abs ($78 - $228) * choose (h$58 * w$59 - 2) (k$60 - 2) else $84\n                ) $79 (range w$59)\n            ) $74 (range h$58)\n        ) $227 (range w$59),) 1000000007).0\n    ) 0 (range h$58)\n", "cxx": "#include \"jikka/modulo_matrix.hpp\"\n#include \"jikka/not_modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t h, int64_t w, int64_t k) {\n  int64_t x = 0ll;\n  for (int32_t i = 0; i < h; ++i) {\n    int64_t x2 = x;\n    for (int32_t i2 = 0; i2 < w; ++i2) {\n      for (int32_t i3 = 0; i3 < h; ++i3) {\n        for (int32_t i4 = 0; i4 < w; ++i4) {\n          x2 = std::array<int64_t, 2>{i, i2} < std::array<int64_t, 2>{i3, i4}\n                   ? x2 +\n                         std::abs(-i2 + i4) *\n                             jikka::notmod::choose(h * w - 2ll, k - 2ll) +\n                         std::abs(i3 - i) *\n                             jikka::notmod::choose(h * w - 2ll, k - 2ll)\n                   : x2;\n        }\n      }\n    }\n    x = jikka::modmat::floormod<1>(std::array<int64_t, 1>{x2}, 1000000007ll)[0];\n  }\n  return x;\n}\nint main() {\n  int64_t x3 = -1ll;\n  int64_t x4 = -1ll;\n  int64_t x5 = -1ll;\n  std::cin >> x3;\n  std::cin >> x4;\n  std::cin >> x5;\n  auto x6 = solve(x3, x4, x5);\n  std::cout << x6 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/wip/tle/abc134_c.py", "python": "# https://atcoder.jp/contests/abc134/tasks/abc134_c\nfrom typing import *\n\ndef solve(N: int, A: List[int]) -> List[int]:\n    # assert 2 <= N <= 200000\n    # assert len(A) == N\n    # assert all(0 <= A_i <= 200000 for A_i in A)\n\n    ans = [-1 for _ in range(N)]\n    for i in range(N):\n        ans[i] = max((0 if j == i else A[j]) for j in range(N))\n    return ans\n", "rpython": "def solve(N: int, A: List[int]) -> List[int]:\n    ans: $0 = [- 1 for _ in range(N)]\n    for i in range(N):\n        ans[i]: $1 = max(0 if j == i else A[j] for j in range(N))\n    return ans\n", "core": "fun (N$36: int) (A$37: int list) ->\n    map (fun ($54: int) ->\n        maximum (map (fun ($58: int) ->\n            if - $54 + $58 == 0 then 0 else A$37[$58]\n        ) (range N$36))\n    ) (range N$36)\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nstd::vector<int64_t> solve(int64_t N, std::vector<int64_t> A) {\n  std::vector<int64_t> mapped(N);\n  for (int32_t i = 0; i < int32_t(N); ++i) {\n    std::vector<int64_t> mapped2(N);\n    for (int32_t i2 = 0; i2 < int32_t(N); ++i2) {\n      mapped2[i2] = -i + i2 == 0ll ? 0ll : A[i2];\n    }\n    int64_t max = *std::max_element(mapped2.begin(), mapped2.end());\n    mapped[i] = max;\n  }\n  return mapped;\n}\nint main() {\n  int64_t x = -1ll;\n  int64_t x2 = -1ll;\n  std::cin >> x;\n  std::cin >> x2;\n  std::vector<int64_t> x3(x2, -1ll);\n  for (int32_t i3 = 0; i3 < x2; ++i3) {\n    std::cin >> x3[i3];\n  }\n  auto x4 = solve(x, x3);\n  std::cout << int32_t(x4.size()) << ' ';\n  for (int32_t i4 = 0; i4 < int32_t(x4.size()); ++i4) {\n    std::cout << x4[i4] << ' ';\n  }\n}\n"}, {"path": "examples/wip/tle/codefestival_2015_final_d.py", "python": "# https://atcoder.jp/contests/code-festival-2015-final-open/tasks/codefestival_2015_final_d\nfrom typing import *\n\ndef solve(n: int, s: List[int], t: List[int]) -> int:\n    assert 2 <= n <= 10 ** 5\n    assert len(s) == n\n    assert len(t) == n\n    ans = n\n    for i in range(n):\n        ans_i = max(sum((1 if s[j] <= x < t[j] else 0) for j in range(n) if j != i) for x in range(max(t)))\n        ans = min(ans, ans_i)\n    return ans\n", "rpython": "def solve(n: int, s: List[int], t: List[int]) -> int:\n    assert 2 <= n and n <= 10 ** 5\n    assert len(s) == n\n    assert len(t) == n\n    ans: $4 = n\n    for i in range(n):\n        ans_i: $5 = max(sum(1 if s[j] <= x and x < t[j] else 0 for j in range(n) if j != i) for x in range(max(t)))\n        ans: $9 = min(ans, ans_i)\n    return ans\n", "core": "fun (n$69: int) (s$70: int list) (t$71: int list) ->\n    assert - n$69 + 2 <= 0 && n$69 - 100000 <= 0 in\n    assert - n$69 + len s$70 == 0 in\n    assert - n$69 + len t$71 == 0 in\n    minimum (cons n$69 (map (fun ($87: int) ->\n        maximum (map (fun ($91: int) ->\n            sum (map (fun ($94: int) ->\n                if - $91 + s$70[$94] <= 0 && $91 - t$71[$94] < 0 then 1 else 0\n            ) (filter (fun ($109: int) ->\n                - $87 + $109 != 0\n            ) (range n$69)))\n        ) (range (maximum t$71)))\n    ) (range n$69)))\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t n, std::vector<int64_t> s, std::vector<int64_t> t) {\n  assert(-n + 2ll <= 0ll and n - 100000ll <= 0ll);\n  assert(-n + int64_t(s.size()) == 0ll);\n  assert(-n + int64_t(t.size()) == 0ll);\n  std::vector<int64_t> mapped(n);\n  for (int32_t i = 0; i < int32_t(n); ++i) {\n    int64_t max_t = *std::max_element(t.begin(), t.end());\n    std::vector<int64_t> mapped2(max_t);\n    for (int32_t i2 = 0; i2 < int32_t(max_t); ++i2) {\n      std::vector<int64_t> filtered;\n      for (int32_t i3 = 0; i3 < n; ++i3) {\n        if (-i + i3 != 0ll) {\n          filtered.push_back(i3);\n        }\n      }\n      std::vector<int64_t> mapped3(filtered.size());\n      for (int32_t i4 = 0; i4 < int32_t(filtered.size()); ++i4) {\n        mapped3[i4] =\n            -i2 + s[filtered[i4]] <= 0ll and i2 - t[filtered[i4]] < 0ll ? 1ll\n                                                                        : 0ll;\n      }\n      int64_t sum = std::accumulate(mapped3.begin(), mapped3.end(), 0ll);\n      mapped2[i2] = sum;\n    }\n    int64_t max = *std::max_element(mapped2.begin(), mapped2.end());\n    mapped[i] = max;\n  }\n  std::vector<int64_t> x;\n  x.push_back(n);\n  x.insert(x.end(), mapped.begin(), mapped.end());\n  int64_t min = *std::min_element(x.begin(), x.end());\n  return min;\n}\nint main() {\n  int64_t x2 = -1ll;\n  int64_t x3 = -1ll;\n  int64_t x4 = -1ll;\n  std::cin >> x2;\n  std::cin >> x3;\n  std::vector<int64_t> x5(x3, -1ll);\n  for (int32_t i5 = 0; i5 < x3; ++i5) {\n    std::cin >> x5[i5];\n  }\n  std::cin >> x4;\n  std::vector<int64_t> x6(x4, -1ll);\n  for (int32_t i6 = 0; i6 < x4; ++i6) {\n    std::cin >> x6[i6];\n  }\n  auto x7 = solve(x2, x5, x6);\n  std::cout << x7 << ' ';\n}\n"}, {"path": "examples/wip/tle/m_solutions2019_e.py", "python": "# https://atcoder.jp/contests/m-solutions2019/tasks/m_solutions2019_e\nfrom typing import *\n\nMOD: int = 1000003\n\ndef solve1(x: int, d: int, n: int) -> int:\n    assert 0 <= x < MOD\n    assert 0 <= d < MOD\n    assert 0 <= n < 10 ** 9\n\n    return product(x + i * d for i in range(n)) % MOD\n\ndef solve(Q: int, x: List[int], d: List[int], n: List[int]) -> List[int]:\n    assert 1 <= Q <= 100000\n    assert len(x) == Q\n    assert all(0 <= x_i < MOD for x_i in x)\n    assert len(d) == Q\n    assert all(0 <= d_i < MOD for d_i in d)\n    assert len(n) == Q\n    assert all(0 <= n_i < MOD for n_i in n)\n\n    ans = [-1 for _ in range(Q)]\n    for i in range(Q):\n        ans[i] = solve1(x[i], d[i], n[i])\n    return ans\n", "rpython": "MOD: int = 1000003\ndef solve1(x: int, d: int, n: int) -> int:\n    assert 0 <= x and x < MOD\n    assert 0 <= d and d < MOD\n    assert 0 <= n and n < 10 ** 9\n    return product(x + i * d for i in range(n)) % MOD\ndef solve(Q: int, x: List[int], d: List[int], n: List[int]) -> List[int]:\n    assert 1 <= Q and Q <= 100000\n    assert len(x) == Q\n    assert all(0 <= x_i and x_i < MOD for x_i in x)\n    assert len(d) == Q\n    assert all(0 <= d_i and d_i < MOD for d_i in d)\n    assert len(n) == Q\n    assert all(0 <= n_i and n_i < MOD for n_i in n)\n    ans: $17 = [- 1 for _ in range(Q)]\n    for i in range(Q):\n        ans[i]: $18 = solve1(x[i], d[i], n[i])\n    return ans\n", "core": "fun (Q$121: int) (x$122: int list) (d$123: int list) (n$124: int list) ->\n    assert - Q$121 + 1 <= 0 && Q$121 - 100000 <= 0 in\n    assert - Q$121 + len x$122 == 0 in\n    assert all (map (fun ($147: int) ->\n        - $147 <= 0 && $147 - 1000003 < 0\n    ) x$122) in\n    assert - Q$121 + len d$123 == 0 in\n    assert all (map (fun ($151: int) ->\n        - $151 <= 0 && $151 - 1000003 < 0\n    ) d$123) in\n    assert - Q$121 + len n$124 == 0 in\n    assert all (map (fun ($155: int) ->\n        - $155 <= 0 && $155 - 1000003 < 0\n    ) n$124) in\n    map (fun ($165: int) ->\n        assert - x$122[$165] <= 0 && x$122[$165] - 1000003 < 0 in\n        assert - d$123[$165] <= 0 && d$123[$165] - 1000003 < 0 in\n        assert - n$124[$165] <= 0 && n$124[$165] - 1000000000 < 0 in\n        modproduct (map (fun ($331: int) ->\n            modplus (modmult ($331 % 1000003) (d$123[$165] % 1000003) 1000003) (x$122[$165] % 1000003) 1000003\n        ) (range n$124[$165])) 1000003\n    ) (range Q$121)\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nstd::vector<int64_t> solve(int64_t Q, std::vector<int64_t> x,\n                           std::vector<int64_t> d, std::vector<int64_t> n) {\n  assert(-Q + 1ll <= 0ll and Q - 100000ll <= 0ll);\n  assert(-Q + int64_t(x.size()) == 0ll);\n  for (int64_t x2 : x) {\n    assert(-x2 <= 0ll and x2 - 1000003ll < 0ll);\n  }\n  assert(-Q + int64_t(d.size()) == 0ll);\n  for (int64_t x3 : d) {\n    assert(-x3 <= 0ll and x3 - 1000003ll < 0ll);\n  }\n  assert(-Q + int64_t(n.size()) == 0ll);\n  for (int64_t x4 : n) {\n    assert(-x4 <= 0ll and x4 - 1000003ll < 0ll);\n  }\n  std::vector<int64_t> mapped(Q);\n  for (int32_t i = 0; i < int32_t(Q); ++i) {\n    assert(-x[i] <= 0ll and x[i] - 1000003ll < 0ll);\n    assert(-d[i] <= 0ll and d[i] - 1000003ll < 0ll);\n    assert(-n[i] <= 0ll and n[i] - 1000000000ll < 0ll);\n    std::vector<int64_t> mapped2(n[i]);\n    for (int32_t i2 = 0; i2 < int32_t(n[i]); ++i2) {\n      mapped2[i2] = jikka::mod::plus(\n          jikka::mod::mult(jikka::floormod(i2, 1000003ll),\n                           jikka::floormod(d[i], 1000003ll), 1000003ll),\n          jikka::floormod(x[i], 1000003ll), 1000003ll);\n    }\n    int64_t prod = 1ll;\n    for (int64_t x5 : mapped2) {\n      prod = jikka::mod::mult(prod, x5, 1000003ll);\n    }\n    mapped[i] = prod;\n  }\n  return mapped;\n}\nint main() {\n  int64_t x6 = -1ll;\n  int64_t x7 = -1ll;\n  int64_t x8 = -1ll;\n  int64_t x9 = -1ll;\n  std::cin >> x6;\n  std::cin >> x7;\n  std::vector<int64_t> x10(x7, -1ll);\n  for (int32_t i3 = 0; i3 < x7; ++i3) {\n    std::cin >> x10[i3];\n  }\n  std::cin >> x8;\n  std::vector<int64_t> x11(x8, -1ll);\n  for (int32_t i4 = 0; i4 < x8; ++i4) {\n    std::cin >> x11[i4];\n  }\n  std::cin >> x9;\n  std::vector<int64_t> x12(x9, -1ll);\n  for (int32_t i5 = 0; i5 < x9; ++i5) {\n    std::cin >> x12[i5];\n  }\n  auto x13 = solve(x6, x10, x11, x12);\n  std::cout << int32_t(x13.size()) << ' ';\n  for (int32_t i6 = 0; i6 < int32_t(x13.size()); ++i6) {\n    std::cout << x13[i6] << ' ';\n  }\n}\n"}, {"path": "examples/wip/tle/point_add_range_sum.py", "python": "# https://judge.yosupo.jp/problem/point_add_range_sum\n\nfrom typing import *\n\ndef solve(n: int, q: int, a: List[int], t: List[int], args1: List[int], args2: List[int]) -> List[int]:\n    ans = []\n    for i in range(q):\n        if t[i] == 0:\n            p = args1[i]\n            x = args2[i]\n            a[p] += x\n        else:\n            l = args1[i]\n            r = args2[i]\n            ans.append(sum(a[l:r]))\n    return ans\n\ndef main() -> None:\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    t = list(range(q))\n    args1 = list(range(q))\n    args2 = list(range(q))\n    for i in range(q):\n        t[i], args1[i], args2[i] = map(int, input().split())\n    ans = solve(n, q, a, t, args1, args2)\n    for i in range(len(ans)):\n        print(ans[i])\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, q: int, a: List[int], t: List[int], args1: List[int], args2: List[int]) -> List[int]:\n    ans: $0 = []\n    for i in range(q):\n        if t[i] == 0:\n            p: $3 = args1[i]\n            x: $4 = args2[i]\n            a[p] += x\n        else:\n            l: $5 = args1[i]\n            r: $6 = args2[i]\n            ans.append(sum(a[l:r]))\n    return ans\ndef main() -> None:\n    n, q: $7 = map(int, input().split())\n    a: $8 = list(map(int, input().split()))\n    assert len(a) == n\n    t: $10 = list(range(q))\n    args1: $11 = list(range(q))\n    args2: $12 = list(range(q))\n    for i in range(q):\n        t[i], args1[i], args2[i]: $13 = map(int, input().split())\n    ans: $14 = solve(n, q, a, t, args1, args2)\n    for i in range(len(ans)):\n        print(ans[i])\n", "core": "const (fun (q$102: int) (a$103: int list) (t$104: int list) (args1$105: int list) (args2$106: int list) ->\n    (foldl (fun ($116: int list * int list) ($115: int) ->\n        let $124: int list * int list = if t$104[$115] == 0 then ($116.0[args1$105[$115] <- args2$106[$115] + $116.0[args1$105[$115]]], $116.1) else ($116.0, snoc $116.1 (let $243: int list = scanl (fun ($244: int) ($245: int) ->\n            $244 + $245\n        ) 0 $116.0\n        in - $243[args1$105[$115]] + $243[args2$106[$115]]))\n        in ($124.0, $124.1)\n    ) (a$103, nil) (range q$102)).1\n)\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nstd::vector<int64_t> solve(int64_t n, int64_t q, std::vector<int64_t> a,\n                           std::vector<int64_t> t, std::vector<int64_t> args1,\n                           std::vector<int64_t> args2) {\n  std::vector<int64_t> x;\n  for (int32_t i = 0; i < q; ++i) {\n    std::array<std::vector<int64_t>, 2> x2;\n    if (t[i] == 0ll) {\n      std::vector<int64_t> a2 = a;\n      a2[args1[i]] = args2[i] + a[args1[i]];\n      x2 = std::array<std::vector<int64_t>, 2>{a2, x};\n    } else {\n      std::vector<int64_t> x3(a.size() + 1);\n      x3[0] = 0ll;\n      for (int32_t i2 = 0; i2 < int32_t(a.size()); ++i2) {\n        x3[i2 + 1] = x3[i2] + a[i2];\n      }\n      std::vector<int64_t> x4 = x;\n      x4.push_back(-x3[args1[i]] + x3[args2[i]]);\n      x2 = std::array<std::vector<int64_t>, 2>{a, x4};\n    }\n    std::vector<int64_t> x5 = x2[0];\n    std::vector<int64_t> x6 = x2[1];\n    a = x5;\n    x = x6;\n  }\n  return x;\n}\nint main() {\n  int64_t x7 = -1ll;\n  int64_t x8 = -1ll;\n  std::cin >> x7;\n  std::vector<int64_t> x9(x7, -1ll);\n  std::cin >> x8;\n  std::vector<int64_t> x10(x8, -1ll);\n  std::vector<int64_t> x11(x8, -1ll);\n  std::vector<int64_t> x12(x8, -1ll);\n  for (int32_t i3 = 0; i3 < x7; ++i3) {\n    std::cin >> x9[i3];\n  }\n  for (int32_t i4 = 0; i4 < x8; ++i4) {\n    std::cin >> x10[i4];\n    std::cin >> x11[i4];\n    std::cin >> x12[i4];\n  }\n  auto x13 = solve(x7, x8, x9, x10, x11, x12);\n  for (int32_t i5 = 0; i5 < int32_t(x13.size()); ++i5) {\n    std::cout << x13[i5] << ' ';\n    std::cout << '\\n' << ' ';\n  }\n}\n"}, {"path": "examples/wip/tle/yukicoder_1618.py", "python": "# https://yukicoder.me/problems/no/1618\nfrom typing import *\n\n\ndef solve(n: int, a: List[int], b: List[int]) -> List[int]:\n    c = [0 for _ in range(2 * n)]\n    for i in range(n):\n        for j in range(n):\n            c[i + j + 1] += (i + 1) * a[j] + (j + 1) * b[i]\n    return c\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    assert len(a) == n\n    b = list(map(int, input().split()))\n    assert len(b) == n\n    ans = solve(n, a, b)\n    print(*ans)\n\n\nif __name__ == '__main__':\n    main()\n", "rpython": "def solve(n: int, a: List[int], b: List[int]) -> List[int]:\n    c: $0 = [0 for _ in range(2 * n)]\n    for i in range(n):\n        for j in range(n):\n            c[i + j + 1] += i + 1 * a[j] + j + 1 * b[i]\n    return c\ndef main() -> $7:\n    n: $1 = int(input())\n    a: $2 = list(map(int, input().split()))\n    assert len(a) == n\n    b: $4 = list(map(int, input().split()))\n    assert len(b) == n\n    ans: $6 = solve(n, a, b)\n    print(*ans)\n", "core": "fun (n$64: int) (a$65: int list) (b$66: int list) ->\n    foldl (fun ($78: int list) ($77: int) ->\n        foldl (fun ($83: int list) ($82: int) ->\n            $83[$77 + $82 + 1 <- $77 * a$65[$82] + $82 * b$66[$77] + $83[$77 + $82 + 1] + a$65[$82] + b$66[$77]]\n        ) $78 (range n$64)\n    ) (replicate (n$64 * 2) 0) (range n$64)\n", "cxx": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nstd::vector<int64_t> solve(int64_t n, std::vector<int64_t> a,\n                           std::vector<int64_t> b) {\n  std::vector<int64_t> mapped(n * 2ll, 0ll);\n  for (int32_t i = 0; i < n; ++i) {\n    for (int32_t i2 = 0; i2 < n; ++i2) {\n      mapped[i + i2 + 1ll] =\n          i * a[i2] + i2 * b[i] + mapped[i + i2 + 1ll] + a[i2] + b[i];\n    }\n  }\n  return mapped;\n}\nint main() {\n  int64_t x = -1ll;\n  std::cin >> x;\n  std::vector<int64_t> x2(x, -1ll);\n  std::vector<int64_t> x3(x, -1ll);\n  for (int32_t i3 = 0; i3 < x; ++i3) {\n    std::cin >> x2[i3];\n  }\n  for (int32_t i4 = 0; i4 < x; ++i4) {\n    std::cin >> x3[i4];\n  }\n  auto x4 = solve(x, x2, x3);\n  for (int32_t i5 = 0; i5 < int32_t(x4.size()); ++i5) {\n    std::cout << x4[i5] << ' ';\n  }\n  std::cout << '\\n' << ' ';\n}\n"}, {"path": "examples/wip/tle/yukicoder_1649.py", "python": "# https://yukicoder.me/problems/no/1649\nfrom typing import *\n\nMOD = 998244353\n\n\ndef solve(N: int, x: List[int], y: List[int]) -> int:\n    ans = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            ans += (abs(x[i] - x[j]) + abs(y[i] - y[j])) ** 2\n    return ans % MOD\n\n\n# generated by oj-template v4.8.0 (https://github.com/online-judge-tools/template-generator)\ndef main():\n    N = int(input())\n    x = list(range(N))\n    y = list(range(N))\n    for i in range(N):\n        x[i], y[i] = map(int, input().split())\n    ans = solve(N, x, y)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n", "rpython": "MOD: $0 = 998244353\ndef solve(N: int, x: List[int], y: List[int]) -> int:\n    ans: $1 = 0\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            ans += abs(x[i] - x[j]) + abs(y[i] - y[j]) ** 2\n    return ans % MOD\ndef main() -> $7:\n    N: $2 = int(input())\n    x: $3 = list(range(N))\n    y: $4 = list(range(N))\n    for i in range(N):\n        x[i], y[i]: $5 = map(int, input().split())\n    ans: $6 = solve(N, x, y)\n    print(ans)\n", "core": "fun (N$57: int) (x$58: int list) (y$59: int list) ->\n    foldl (fun ($156: int) ($157: int) ->\n        if range (- $157 + N$57 - 1) == nil then $156 else modplus (modplus (modplus ($156 % 998244353) (modsum (map (fun ($165: int) ->\n            modmult (abs (x$58[$157] - x$58[$157 + $165 + 1]) % 998244353) (abs (x$58[$157] - x$58[$157 + $165 + 1]) % 998244353) 998244353\n        ) (range (- $157 + N$57 - 1))) 998244353) 998244353) (modsum (map (fun ($166: int) ->\n            modmult (abs (y$59[$157] - y$59[$157 + $166 + 1]) % 998244353) (abs (y$59[$157] - y$59[$157 + $166 + 1]) % 998244353) 998244353\n        ) (range (- $157 + N$57 - 1))) 998244353) 998244353) (modmult (modsum (map (fun ($167: int) ->\n            modmult (abs (x$58[$157] - x$58[$157 + $167 + 1]) % 998244353) (abs (y$59[$157] - y$59[$157 + $167 + 1]) % 998244353) 998244353\n        ) (range (- $157 + N$57 - 1))) 998244353) 2 998244353) 998244353\n    ) 0 (range (N$57 - 1))\n", "cxx": "#include \"jikka/divmod.hpp\"\n#include \"jikka/modulo.hpp\"\n#include \"jikka/range.hpp\"\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iostream>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <vector>\nint64_t solve(int64_t N, std::vector<int64_t> x, std::vector<int64_t> y) {\n  int64_t x2 = 0ll;\n  for (int32_t i = 0; i < N - 1ll; ++i) {\n    int64_t x3;\n    if (jikka::range(-i + N - 1ll) == std::vector<int64_t>()) {\n      x3 = x2;\n    } else {\n      std::vector<int64_t> mapped(-i + N - 1ll);\n      for (int32_t i2 = 0; i2 < int32_t(-i + N - 1ll); ++i2) {\n        mapped[i2] = jikka::mod::mult(\n            jikka::floormod(std::abs(x[i] - x[i + i2 + 1ll]), 998244353ll),\n            jikka::floormod(std::abs(x[i] - x[i + i2 + 1ll]), 998244353ll),\n            998244353ll);\n      }\n      int64_t sum = 0ll;\n      for (int64_t x4 : mapped) {\n        sum += jikka::floormod(x4, 998244353ll);\n      }\n      std::vector<int64_t> mapped2(-i + N - 1ll);\n      for (int32_t i3 = 0; i3 < int32_t(-i + N - 1ll); ++i3) {\n        mapped2[i3] = jikka::mod::mult(\n            jikka::floormod(std::abs(y[i] - y[i + i3 + 1ll]), 998244353ll),\n            jikka::floormod(std::abs(y[i] - y[i + i3 + 1ll]), 998244353ll),\n            998244353ll);\n      }\n      int64_t sum2 = 0ll;\n      for (int64_t x5 : mapped2) {\n        sum2 += jikka::floormod(x5, 998244353ll);\n      }\n      std::vector<int64_t> mapped3(-i + N - 1ll);\n      for (int32_t i4 = 0; i4 < int32_t(-i + N - 1ll); ++i4) {\n        mapped3[i4] = jikka::mod::mult(\n            jikka::floormod(std::abs(x[i] - x[i + i4 + 1ll]), 998244353ll),\n            jikka::floormod(std::abs(y[i] - y[i + i4 + 1ll]), 998244353ll),\n            998244353ll);\n      }\n      int64_t sum3 = 0ll;\n      for (int64_t x6 : mapped3) {\n        sum3 += jikka::floormod(x6, 998244353ll);\n      }\n      x3 = jikka::mod::plus(\n          jikka::mod::plus(jikka::mod::plus(jikka::floormod(x2, 998244353ll),\n                                            jikka::floormod(sum, 998244353ll),\n                                            998244353ll),\n                           jikka::floormod(sum2, 998244353ll), 998244353ll),\n          jikka::mod::mult(jikka::floormod(sum3, 998244353ll), 2ll,\n                           998244353ll),\n          998244353ll);\n    }\n    x2 = x3;\n  }\n  return x2;\n}\nint main() {\n  int64_t x7 = -1ll;\n  std::cin >> x7;\n  std::vector<int64_t> x8(x7, -1ll);\n  std::vector<int64_t> x9(x7, -1ll);\n  for (int32_t i5 = 0; i5 < x7; ++i5) {\n    std::cin >> x8[i5];\n    std::cin >> x9[i5];\n  }\n  auto x10 = solve(x7, x8, x9);\n  std::cout << x10 << ' ';\n  std::cout << '\\n' << ' ';\n}\n"}], "errors": [{"path": "examples/errors/toplevel_expr_statements.py", "python": "if __name__ == '__main__':  # err\n    a = int(input())\n    print(a ** 2)\n", "error": "Semantic Error (line 1 column 1) (user's mistake?): Failed at Jikka.Python.Convert.ToplevelDecl: only `if __name__ == \"__main__\": main()' is allowed for if statements at toplevel\n1 |if __name__ == '__main__':  # err\n   ^^\n2 |    a = int(input())\n"}, {"path": "examples/errors/type_errors.py", "python": "def solve(n: int) -> bool:\n    a = n + True  # err\n    b = 2 * n\n    return b  # err\n", "error": "Type Error (line 2 column 13) (user's mistake?): Jikka.RestrictedPython.Convert.TypeInfer: failed to solve type equations: failed to unify type int and type bool: type int is not type bool\n1 |def solve(n: int) -> bool:\n2 |    a = n + True  # err\n               ^^^^\n3 |    b = 2 * n\n\nType Error (line 4 column 12) (user's mistake?): Jikka.RestrictedPython.Convert.TypeInfer: failed to solve type equations: failed to unify type bool and type int: type bool is not type int\n3 |    b = 2 * n\n4 |    return b  # err\n              ^\n"}, {"path": "examples/errors/undefined_identifiers.py", "python": "def solve(x: int) -> int:\n    x = y  # err\n    z = x + 1\n    return y  # err\n", "error": "Symbol Error (line 2 column 9) (user's mistake?): Jikka.RestrictedPython.Convert.Alpha: undefined identifier: y\n1 |def solve(x: int) -> int:\n2 |    x = y  # err\n           ^\n3 |    z = x + 1\n\nSymbol Error (line 4 column 12) (user's mistake?): Jikka.RestrictedPython.Convert.Alpha: undefined identifier: y\n3 |    z = x + 1\n4 |    return y  # err\n              ^\n"}]}